diff -urN smcroute-1.99.2/ChangeLog smcroute/ChangeLog
--- smcroute-1.99.2/ChangeLog	2013-07-16 06:59:37.000000000 +0200
+++ smcroute/ChangeLog	2014-06-30 12:22:34.841800835 +0200
@@ -1,3 +1,6 @@
+smcroute 1.99.2 -> 2.0.0
+ * Refactor to use libev for event handling instead of poll() etc.
+
 smcroute 1.99.1 -> 1.99.2
  * Fix issue #2: Loop forever bug when deleting new (*,G) sourceless routes
    Bug report and patch by Jean-Baptiste Maillet
diff -urN smcroute-1.99.2/configure smcroute/configure
--- smcroute-1.99.2/configure	2013-07-16 06:59:37.000000000 +0200
+++ smcroute/configure	2014-06-30 12:22:34.845800674 +0200
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.69 for smcroute 1.99.2.
+# Generated by GNU Autoconf 2.69 for smcroute 2.0.0-beta1.
 #
 # Report bugs to <troglobit@gmail.com>.
 #
@@ -580,8 +580,8 @@
 # Identity of this package.
 PACKAGE_NAME='smcroute'
 PACKAGE_TARNAME='smcroute'
-PACKAGE_VERSION='1.99.2'
-PACKAGE_STRING='smcroute 1.99.2'
+PACKAGE_VERSION='2.0.0-beta1'
+PACKAGE_STRING='smcroute 2.0.0-beta1'
 PACKAGE_BUGREPORT='troglobit@gmail.com'
 PACKAGE_URL=''
 
@@ -1225,7 +1225,7 @@
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures smcroute 1.99.2 to adapt to many kinds of systems.
+\`configure' configures smcroute 2.0.0-beta1 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1286,7 +1286,7 @@
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of smcroute 1.99.2:";;
+     short | recursive ) echo "Configuration of smcroute 2.0.0-beta1:";;
    esac
   cat <<\_ACEOF
 
@@ -1366,7 +1366,7 @@
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-smcroute configure 1.99.2
+smcroute configure 2.0.0-beta1
 generated by GNU Autoconf 2.69
 
 Copyright (C) 2012 Free Software Foundation, Inc.
@@ -1843,7 +1843,7 @@
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by smcroute $as_me 1.99.2, which was
+It was created by smcroute $as_me 2.0.0-beta1, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
@@ -3450,8 +3450,6 @@
 
 
 
-# Checks for libraries.
-
 # Checks for header files.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
 $as_echo_n "checking for ANSI C header files... " >&6; }
@@ -4964,7 +4962,7 @@
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by smcroute $as_me 1.99.2, which was
+This file was extended by smcroute $as_me 2.0.0-beta1, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -5026,7 +5024,7 @@
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-smcroute config.status 1.99.2
+smcroute config.status 2.0.0-beta1
 configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
diff -urN smcroute-1.99.2/configure.ac smcroute/configure.ac
--- smcroute-1.99.2/configure.ac	2013-07-16 06:59:37.000000000 +0200
+++ smcroute/configure.ac	2014-06-30 12:22:34.845800674 +0200
@@ -2,7 +2,7 @@
 # Process this file with autoconf to produce a configure script.
 
 AC_PREREQ(2.61)
-AC_INIT(smcroute, 1.99.2, troglobit@gmail.com)
+AC_INIT(smcroute, 2.0.0-beta1, troglobit@gmail.com)
 AC_CONFIG_SRCDIR([src/mclab.h])
 AC_CONFIG_HEADER([src/config.h])
 AC_CONFIG_FILES([Makefile src/Makefile doc/Makefile])
@@ -13,8 +13,6 @@
 # The pidfile() code needs asprintf(), which relies on -D_GNU_SOURCE
 AC_GNU_SOURCE
 
-# Checks for libraries.
-
 # Checks for header files.
 AC_HEADER_STDC
 AC_CHECK_HEADERS([arpa/inet.h fcntl.h netinet/in.h stdlib.h string.h \
diff -urN smcroute-1.99.2/Makefile.in smcroute/Makefile.in
--- smcroute-1.99.2/Makefile.in	2013-07-16 06:59:37.000000000 +0200
+++ smcroute/Makefile.in	2014-06-30 12:22:34.841800835 +0200
@@ -11,7 +11,10 @@
 
 RM             ?= rm -f
 CC             ?= @CC@
+CHECK          ?= cppcheck
 CFLAGS         += @CFLAGS@
+CPPFLAGS       += @CPPFLAGS@ -DEV_STANDALONE=1 -D__OPTIMIZE_SIZE__
+CHECK_FLAGS     = --enable=all --inconclusive --quiet --verbose
 
 prefix         ?= @prefix@
 exec_prefix    ?= @exec_prefix@
@@ -36,6 +39,9 @@
 	@make -C src $@
 	-@$(RM) -r $(DESTDIR)$(docdir)
 
+check:
+	@make -C src $@
+
 clean:
 	@make -C src $@
 
diff -urN smcroute-1.99.2/src/cmdpkt.c smcroute/src/cmdpkt.c
--- smcroute-1.99.2/src/cmdpkt.c	2013-07-16 06:59:37.000000000 +0200
+++ smcroute/src/cmdpkt.c	2014-06-30 12:22:34.845800674 +0200
@@ -1,29 +1,25 @@
-/*
-**  smcroute - static multicast routing control 
-**  Copyright (C) 2001-2005 Carsten Schill <carsten@cschill.de>
-**  Copyright (C) 2006-2009 Julien BLACHE <jb@jblache.org>
-**  Copyright (C) 2009      Todd Hayton <todd.hayton@gmail.com>
-**  Copyright (C) 2009-2011 Micha Lenk <micha@debian.org>
-**
-**  This program is free software; you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation; either version 2 of the License, or
-**  (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
-**
-**  $Id: cmdpkt.c 85 2011-08-08 16:47:53Z micha $	
-**
-**  This module contains the functions to build and convert IPC command packets
-**
-*/
+/* IPC command parser and builder for daemon and client
+ *
+ * Copyright (C) 2001-2005  Carsten Schill <carsten@cschill.de>
+ * Copyright (C) 2006-2009  Julien BLACHE <jb@jblache.org>
+ * Copyright (C) 2009       Todd Hayton <todd.hayton@gmail.com>
+ * Copyright (C) 2009-2011  Micha Lenk <micha@debian.org>
+ * Copyright (C) 2011-2013  Joachim Nilsson <troglobit@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ */
 
 #include <sys/socket.h>
 #include <netinet/in.h>
@@ -31,12 +27,20 @@
 
 #include "mclab.h"
 
-/*
-** Builds an command packet with the command 'cmd' and 'count' arguments
-** from 'argv'.
-**
-** returns: - pointer to the dyn. allocated command packet
-*/
+
+/**
+ * cmd_build - Create IPC command to send to daemon
+ * @cmd:   Command, one of 'a', 'r', 'j' or 'l'
+ * @argv:  Vector of arguments for @cmd
+ * @count: Number of arguments in @argv
+ *
+ * Builds an command packet with the command @cmd and @count number of
+ * arguments from @argv.
+ *
+ * Returns:
+ * Pointer to a dynamically allocated command packet, or %NULL on failure
+ * to allocate enought memory.
+ */
 void *cmd_build(char cmd, const char *argv[], int count)
 {
 	int i;
@@ -50,15 +54,18 @@
 
 	/* resulting packet size */
 	packet_len = sizeof(struct cmd) + arg_len + 1;
-	if (packet_len > MX_CMDPKT_SZ)
-		smclog(LOG_ERR, 0, "option too big");
+	if (packet_len > MX_CMDPKT_SZ) {
+		errno = EMSGSIZE;
+		return NULL;
+	}
 
 	/* build packet */
-	if (!(packet = malloc(packet_len)))
-		smclog(LOG_ERR, errno, "out of memory for option arguments");
+	packet = malloc(packet_len);
+	if (!packet)
+		return NULL;
 
-	packet->len = packet_len;
-	packet->cmd = cmd;
+	packet->len   = packet_len;
+	packet->cmd   = cmd;
 	packet->count = count;
 
 	/* copy args */
@@ -73,14 +80,18 @@
 	return packet;
 }
 
-/*
-** Converts a command packet 'packet' to an mroute struct 'mroute' for the
-** 'add' and 'remove' command. The IP version is determined by searching
-** for ':' in the address strings to indicate IPv6 addresses.
-**
-** returns: - NULL if the conversion succeeded
-**          - an error string with a hint why the conversion failed
-*/
+/**
+ * cmd_convert_to_mroute - Convert IPC command from client to desired mulicast route
+ * @mroute: Pointer to &struct mroute to convert to
+ * @packet: Pointer to &struct cmd IPC command
+ *
+ * Converts a command @packet to an @mroute for the 'add' and 'remove'
+ * commands.  The IP version is determined by searching for ':' in the
+ * address strings to indicate IPv6 addresses.
+ *
+ * Returns:
+ * %NULL on success, or an error string with a hint why the operation failed.
+ */
 const char *cmd_convert_to_mroute(struct mroute *mroute, const struct cmd *packet)
 {
 	char *arg = (char *)packet->argv;
@@ -129,14 +140,6 @@
 	return NULL;
 }
 
-/*
-** Converts a command packet 'packet' to an mroute4 struct 'mroute' for the
-** 'add' and 'remove' command.
-**
-** returns: - NULL if the conversion succeeded
-**          - an error string with a hint why the conversion failed
-**          
-*/
 const char *cmd_convert_to_mroute4(struct mroute4 *mroute, const struct cmd *packet)
 {
 	char *arg = (char *)packet->argv;
@@ -156,17 +159,17 @@
 
 	/* get input interface index */
 	if (!*arg || (mroute->inbound = iface_get_vif_by_name(arg)) < 0)
-		return "invalid input interface";
+		return "Invalid input interface";
 
 	/* get origin */
 	arg += strlen(arg) + 1;
 	if (!*arg || (inet_pton(AF_INET, arg, &mroute->sender) <= 0))
-		return "invalid origin IP address";
+		return "Invalid origin IPv4 address";
 
 	/* get multicast group */
 	arg += strlen(arg) + 1;
 	if (!*arg || (inet_pton(AF_INET, arg, &mroute->group) <= 0) || !IN_MULTICAST(ntohl(mroute->group.s_addr)))
-		return "invalid multicast group address";
+		return "Invalid multicast group";
 
 	/*
 	 * Scan output interfaces for the 'add' command only, just ignore it
@@ -177,10 +180,10 @@
 			int vif;
 
 			if ((vif = iface_get_vif_by_name(arg)) < 0)
-				return "invalid output interface";
+				return "Invalid output interface";
 
 			if (vif == mroute->inbound)
-				smclog(LOG_WARNING, 0, "Forwarding multicast to the input interface may not make sense: %s", arg);
+				smclog(LOG_WARNING, 0, "Same outbound interface as inbound %s?", arg);
 
 			mroute->ttl[vif] = 1;	/* Use a TTL threashold */
 		}
@@ -189,14 +192,6 @@
 	return NULL;
 }
 
-/*
-** Converts a command packet 'packet' to an mroute6 struct 'mroute' for the
-** 'add' and 'remove' command.
-**
-** returns: - NULL if the conversion succeeded
-**          - an error string with a hint why the conversion failed
-**          
-*/
 const char *cmd_convert_to_mroute6(struct mroute6 *mroute, const struct cmd *packet)
 {
 	const char *arg = (const char *)(packet + 1);
@@ -210,7 +205,7 @@
 	/* get origin */
 	arg += strlen(arg) + 1;
 	if (!*arg || (inet_pton(AF_INET6, arg, &mroute->sender.sin6_addr) <= 0))
-		return "Invalid origin IP address";
+		return "Invalid origin IPv6 address";
 
 	/* get multicast group */
 	arg += strlen(arg) + 1;
@@ -231,7 +226,7 @@
 				return "Invalid output interface";
 
 			if (mif == mroute->inbound)
-				smclog(LOG_WARNING, 0, "Forwarding multicast to the input interface may not make sense: %s", arg);
+				smclog(LOG_WARNING, 0, "Same outbound interface as inbound %s?", arg);
 
 			mroute->ttl[mif] = 1;	/* Use a TTL threashold */
 		}
diff -urN smcroute-1.99.2/src/ifvc.c smcroute/src/ifvc.c
--- smcroute-1.99.2/src/ifvc.c	2013-07-16 06:59:37.000000000 +0200
+++ smcroute/src/ifvc.c	2014-06-30 12:22:34.849800512 +0200
@@ -1,29 +1,25 @@
-/*
-**  smcroute - static multicast routing control 
-**  Copyright (C) 2001-2005 Carsten Schill <carsten@cschill.de>
-**  Copyright (C) 2006-2009 Julien BLACHE <jb@jblache.org>
-**  Copyright (C) 2009      Todd Hayton <todd.hayton@gmail.com>
-**  Copyright (C) 2009-2011 Micha Lenk <micha@debian.org>
-**
-**  This program is free software; you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation; either version 2 of the License, or
-**  (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
-**
-**  $Id: ifvc.c 85 2011-08-08 16:47:53Z micha $	
-**
-**  This module manages an interface vector of the machine
-**
-*/
+/* Physical and virtual interface API
+ *
+ * Copyright (C) 2001-2005  Carsten Schill <carsten@cschill.de>
+ * Copyright (C) 2006-2009  Julien BLACHE <jb@jblache.org>
+ * Copyright (C) 2009       Todd Hayton <todd.hayton@gmail.com>
+ * Copyright (C) 2009-2011  Micha Lenk <micha@debian.org>
+ * Copyright (C) 2011-2013  Joachim Nilsson <troglobit@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ */
 
 #include <unistd.h>
 #include <sys/types.h>
@@ -32,13 +28,14 @@
 #include "mclab.h"
 
 static unsigned int num_ifaces = 0;
-static struct iface iface_list[MAX_IF];
+static struct iface *iface_list = NULL;
 
-/*
-** Builds up a vector with the interface of the machine. Calls to the other functions of 
-** the module will fail if they are called before the vector is build.
-**          
-*/
+/**
+ * iface_init - Setup vector of active interfaces
+ *
+ * Builds up a vector with active system interfaces.  Must be called
+ * before any other interface functions in this module!
+ */
 void iface_init(void)
 {
 	int family;
@@ -46,16 +43,24 @@
 	struct ifaddrs *ifaddr, *ifa;
 
 	num_ifaces = 0;
-	memset(iface_list, 0, sizeof(iface_list));
+
+	if (iface_list)
+		free(iface_list);
+
+	iface_list = calloc(MAX_IF, sizeof(struct iface));
+	if (!iface_list) {
+		smclog(LOG_ERR, errno, "Failed allocating space for interfaces");
+		return;
+	}
 
 	if (getifaddrs(&ifaddr) == -1) {
-		smclog(LOG_ERR, errno, "Failed to retrieve interface addresses");
+		smclog(LOG_ERR, errno, "Failed retrieving interface addresses");
 		return;
 	}
 
-	for (ifa = ifaddr; ifa != NULL && num_ifaces < ARRAY_ELEMENTS(iface_list); ifa = ifa->ifa_next) {
+	for (ifa = ifaddr; ifa && num_ifaces < MAX_IF; ifa = ifa->ifa_next) {
 		/* Skip interface without internet address */
-		if (ifa->ifa_addr == NULL)
+		if (!ifa->ifa_addr)
 			continue;
 
 		/* Skip non-IPv4 and non-IPv6 interfaces */
@@ -80,15 +85,15 @@
 	freeifaddrs(ifaddr);
 }
 
-/*
-** Returns a pointer to the iface of the interface 'ifname'
-**
-** returns: - pointer to the iface of the requested interface
-**          - NULL if no interface 'ifname' exists
-**          
-**          - if more than one interface 'ifname' exists, chose the
-**            an interface that corresponds to a virtual interface
-*/
+/**
+ * iface_find_by_name - Find an interface by name
+ * @ifname: Interface name
+ *
+ * Returns:
+ * Pointer to a @struct iface of the matching interface, or %NULL if no
+ * interface exists, or is up.  If more than one interface exists, chose
+ * the interface that corresponds to a virtual interface.
+ */
 struct iface *iface_find_by_name(const char *ifname)
 {
 	unsigned int i;
@@ -107,22 +112,21 @@
 	return candidate;
 }
 
-/*
-** Returns a pointer to the iface matching the given 'vif'
-**
-** returns: - pointer to the iface of the requested interface
-**          - NULL if no interface matching 'vif' exists
-**
-**          - if more than one interface 'ifname' exists, chose the
-**            an interface that corresponds to a virtual interface
-*/
+/**
+ * iface_find_by_vif - Find by virtual interface index
+ * @vif: Virtual multicast interface index
+ *
+ * Returns:
+ * Pointer to a @struct iface of the requested interface, or %NULL if no
+ * interface matching @vif exists.
+ */
 struct iface *iface_find_by_vif(int vif)
 {
-	unsigned int i;
-	struct iface *iface;
+	size_t i;
 
 	for (i = 0; i < num_ifaces; i++) {
-		iface = &iface_list[i];
+		struct iface *iface = &iface_list[i];
+
 		if (iface->vif >= 0 && iface->vif == vif)
 			return iface;
 	}
@@ -130,13 +134,14 @@
 	return NULL;
 }
 
-/*
-** Returns a pointer to the iface of the interface 'ifindex'
-**
-** returns: - pointer to the iface of the requested interface
-**          - NULL if no interface 'ifindex' exists
-**          
-*/
+/**
+ * iface_find_by_index - Find by kernel interface index
+ * @ifindex: Kernel interface index
+ *
+ * Returns:
+ * Pointer to a @struct iface of the requested interface, or %NULL if no
+ * interface @ifindex exists.
+ */
 struct iface *iface_find_by_index(unsigned int ifindex)
 {
 	if (ifindex >= num_ifaces)
@@ -146,47 +151,50 @@
 }
 
 
-/*
-** Returns for the virtual interface index for '*iface'
-**
-** returns: - the virtual interface index if the interface is registered
-**          - -1 if no virtual interface exists for the interface 
-**          
-*/
+/**
+ * iface_get_vif - Get virtual interface index for an interface (IPv4)
+ * @iface: Pointer to a @struct iface interface
+ *
+ * Returns:
+ * The virtual interface index if the interface is known and registered
+ * with the kernel, or -1 if no virtual interface exists.
+ */
 int iface_get_vif(struct iface *iface)
 {
-	if (iface == NULL)
+	if (!iface)
 		return -1;
 
 	return iface->vif;
 }
 
-/*
-** Returns for the virtual interface index for '*iface'
-**
-** returns: - the virtual interface index if the interface is registered
-**          - -1 if no virtual interface exists for the interface 
-**          
-*/
+/**
+ * iface_get_mif - Get virtual interface index for an interface (IPv6)
+ * @iface: Pointer to a @struct iface interface
+ *
+ * Returns:
+ * The virtual interface index if the interface is known and registered
+ * with the kernel, or -1 if no virtual interface exists.
+ */
 int iface_get_mif(struct iface *iface __attribute__ ((unused)))
 {
 #ifndef HAVE_IPV6_MULTICAST_ROUTING
 	return -1;
 #else
-	if (iface == NULL)
+	if (!iface)
 		return -1;
 
 	return iface->mif;
 #endif				/* HAVE_IPV6_MULTICAST_ROUTING */
 }
 
-/*
-** Gets the VIF index for a given interface name
-**
-** returns: - index of the VIF
-**          - -1 if no VIF can be found for the interface name
-**          
-*/
+/**
+ * iface_get_vif_by_name - Get virtual interface index by interface name (IPv4)
+ * @ifname: Interface name
+ *
+ * Returns:
+ * The virtual interface index if the interface is known and registered
+ * with the kernel, or -1 if no virtual interface by that name is found.
+ */
 int iface_get_vif_by_name(const char *ifname)
 {
 	int vif;
@@ -203,13 +211,14 @@
 	return vif;
 }
 
-/*
-** Gets the MIF index for a given interface name
-**
-** returns: - index of the MIF
-**          - -1 if no MIF can be found for the interface name
-**          
-*/
+/**
+ * iface_get_mif_by_name - Get virtual interface index by interface name (IPv6)
+ * @ifname: Interface name
+ *
+ * Returns:
+ * The virtual interface index if the interface is known and registered
+ * with the kernel, or -1 if no virtual interface by that name is found.
+ */
 int iface_get_mif_by_name(const char *ifname)
 {
 	int vif;
diff -urN smcroute-1.99.2/src/ipc.c smcroute/src/ipc.c
--- smcroute-1.99.2/src/ipc.c	2013-07-16 06:59:37.000000000 +0200
+++ smcroute/src/ipc.c	2014-06-30 12:22:34.849800512 +0200
@@ -1,29 +1,25 @@
-/*
-**  smcroute - static multicast routing control 
-**  Copyright (C) 2001-2005 Carsten Schill <carsten@cschill.de>
-**  Copyright (C) 2006-2009 Julien BLACHE <jb@jblache.org>
-**  Copyright (C) 2009      Todd Hayton <todd.hayton@gmail.com>
-**  Copyright (C) 2009-2011 Micha Lenk <micha@debian.org>
-**
-**  This program is free software; you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation; either version 2 of the License, or
-**  (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
-**
-**  $Id: ipc.c 85 2011-08-08 16:47:53Z micha $	
-**
-**  This module contains the IPC functions for client and server
-**
-*/
+/* Daemon and client IPC API
+ *
+ * Copyright (C) 2001-2005  Carsten Schill <carsten@cschill.de>
+ * Copyright (C) 2006-2009  Julien BLACHE <jb@jblache.org>
+ * Copyright (C) 2009       Todd Hayton <todd.hayton@gmail.com>
+ * Copyright (C) 2009-2011  Micha Lenk <micha@debian.org>
+ * Copyright (C) 2011-2013  Joachim Nilsson <troglobit@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ */
 
 #include <stddef.h>
 #include <unistd.h>
@@ -35,25 +31,29 @@
 #define SOCKET_PATH "/var/run/smcroute"
 
 /* server's listen socket */
-static int server_sd;
+static int server_sd = -1;
 
 /* connected server or client socket */
 static int client_sd = -1;
 
-/*
-** Inits an IPC listen socket 
-**
-** returns: - the socket descriptor
-*/
+/**
+ * ipc_server_init - Initialise an IPC server socket
+ *
+ * Returns:
+ * The socket descriptor, or -1 on error with @errno set.
+ */
 int ipc_server_init(void)
 {
 	struct sockaddr_un sa;
 	socklen_t len;
 
-	if ((server_sd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
-           smclog(LOG_INIT, errno, "%s: socket() failed", __FUNCTION__);
+	if (server_sd >= 0)
+		close(server_sd);
+
+	server_sd = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (server_sd < 0)
 		return -1;
-	}
+
 #ifdef HAVE_SOCKADDR_UN_SUN_LEN
 	sa.sun_len = 0;	/* <- correct length is set by the OS */
 #endif
@@ -62,33 +62,36 @@
 
 	unlink(SOCKET_PATH);
 
-	len = offsetof(struct sockaddr_un, sun_path)+strlen(SOCKET_PATH);
+	len = offsetof(struct sockaddr_un, sun_path) + strlen(SOCKET_PATH);
 	if (bind(server_sd, (struct sockaddr *)&sa, len) < 0 || listen(server_sd, 1)) {
-           smclog(LOG_INIT, errno, "%s: bind()/listen() failed", __FUNCTION__);
-           close(server_sd);
-           return -1;
+		int err = errno;
+
+		close(server_sd);
+		server_sd = -1;
+		errno = err;
 	}
 
 	return server_sd;
 }
 
-/*
-** Connects to the IPC socket of the server
-**
-** returns: - 0, if function succeeds
-**          - errno value, of connection attempt. Typically: 
-**            - EACCES - Permission denied
-**            - ENOENT - No such file or directory
-**            - ECONREFUSED - Connection refused
-*/
+/**
+ * ipc_client_init - Connects to the IPC socket of the server
+ *
+ * Returns:
+ * POSIX OK(0) on success, non-zero on error with @errno set.
+ * Typically %EACCES, %ENOENT, or %ECONREFUSED.
+ */
 int ipc_client_init(void)
 {
-	int err;
 	struct sockaddr_un sa;
 	socklen_t len;
 
-	if ((client_sd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
-		smclog(LOG_ERR, errno, "%s: socket() failed", __FUNCTION__);
+	if (client_sd >= 0)
+		close(client_sd);
+
+	client_sd = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (client_sd < 0)
+		return -1;
 
 #ifdef HAVE_SOCKADDR_UN_SUN_LEN
 	sa.sun_len = 0;	/* <- correct length is set by the OS */
@@ -98,110 +101,118 @@
 
 	len = offsetof(struct sockaddr_un, sun_path) + strlen(SOCKET_PATH);
 	if (connect(client_sd, (struct sockaddr *)&sa, len) < 0) {
-		err = errno;
+		int err = errno;
 
 		close(client_sd);
 		client_sd = -1;
 
-		return err;
+		errno = err;
+		return -1;
 	}
 
-	smclog(LOG_DEBUG, 0, "%s: client connected, sd %d", __FUNCTION__, client_sd);
-
 	return 0;
 }
 
-/*
-** Reads a message from the IPC socket and stores in 'buf' with a max. size of 'len'. 
-** Connects and resets connection as necessary.
-**
-** returns: Pointer to a successfuly read command packet in 'buf' 
-*/
+/**
+ * ipc_server_read - Read IPC message from client
+ * @buf: Buffer for message
+ * @len: Size of @buf in bytes
+ *
+ * Reads a message from the IPC socket and stores in @buf, respecting
+ * the size @len.  Connects and resets connection as necessary.
+ *
+ * Returns:
+ * Pointer to a successfuly read command packet in @buf, or %NULL on error.
+ */
 struct cmd *ipc_server_read(uint8 buf[], int len)
 {
-	while (1) {
-		size_t size;
-		socklen_t socklen = 0;
-
-		/* wait for connections */
-		if (client_sd < 0) {
-			smclog(LOG_DEBUG, 0, "%s: waiting for connection...", __FUNCTION__);
-
-			if ((client_sd = accept(server_sd, NULL, &socklen)) < 0)
-				smclog(LOG_ERR, errno, "%s: accept() failed incoming connection", __FUNCTION__);
-
-			smclog(LOG_DEBUG, 0, "%s: connection accepted", __FUNCTION__);
-		}
-
-		/* read */
-		memset(buf, 0, len);	/* had some problems with buffer garbage */
-		size = read(client_sd, buf, len);
-		smclog(LOG_DEBUG, 0, "%s: command read(%d, %p, %d) => %zu should be at least %zu", __FUNCTION__,
-		       client_sd, buf, len, size, sizeof(struct cmd));
-
-		/* successful read */
-		if (size >= sizeof(struct cmd)) {
-			struct cmd *p = (struct cmd *)buf;
-
-			if (size == p->len)
-				return p;
-		}
-
-		/* connection lost ? -> reset connection */
-		if (!size) {
-			smclog(LOG_DEBUG, 0, "%s: connection lost", __FUNCTION__);
-			close(client_sd);
-			client_sd = -1;
-			continue;
-		}
+	size_t size;
+	socklen_t socklen = 0;
+
+	/* sanity check */
+	if (server_sd < 0) {
+		errno = EBADFD;
+		return NULL;
+	}
 
-		/* error */
-		smclog(LOG_WARNING, errno, "%s: read() failed", __FUNCTION__);
+	/* wait for connections */
+	if (client_sd < 0) {
+		client_sd = accept(server_sd, NULL, &socklen);
+		if (client_sd < 0)
+			return NULL;
 	}
+
+	size = recv(client_sd, buf, len, 0);
+	if (!size) {
+		close(client_sd);
+		client_sd = -1;
+		errno = ECONNRESET;
+		return NULL;
+	}
+
+	/* successful read */
+	if (size >= sizeof(struct cmd)) {
+		struct cmd *p = (struct cmd *)buf;
+
+		if (size == p->len)
+			return p;
+	}
+
+	errno = ENODATA;
+	return NULL;
 }
 
-/*
-** Sends the IPC message in 'buf' with the size 'Sz' to the peer.
-**
-** returns: - number of bytes written (Sz)
-**          - -1 if write failed
-*/
+/**
+ * ipc_send - Send message to peer
+ * @buf: Message to send
+ * @len: Message length in bytes of @buf
+ *
+ * Sends the IPC message in @buf of the size @len to the peer.
+ *
+ * Returns:
+ * Number of bytes successfully sent, or -1 with @errno on failure.
+ */
 int ipc_send(const void *buf, int len)
 {
-	if (write(client_sd, buf, len) != len) {
-		smclog(LOG_ERR, errno, "%s: write failed (%d)", __FUNCTION__, len);
+	/* sanity check */
+	if (client_sd < 0) {
+		errno = EBADFD;
 		return -1;
 	}
 
+	if (write(client_sd, buf, len) != len)
+		return -1;
+
 	return len;
 }
 
-/*
-** Reads the next IPC message in 'buf' with the max. size 'len' from the peer.
-**
-** returns: - number of bytes read (0..len)
-**          - -1 if read failed
-** 
-*/
+/**
+ * ipc_receive - Receive message from peer
+ * @buf: Buffer to receive message in
+ * @len: Buffer size in bytes
+ *
+ * Waits to receive an IPC message in @buf of max @len bytes from the peer.
+ *
+ * Returns:
+ * Number of bytes successfully received, or -1 with @errno on failure.
+ */
 int ipc_receive(uint8 buf[], int len)
 {
-	int size = read(client_sd, buf, len);
-
-	smclog(LOG_DEBUG, 0, "%s: read (%d)", __FUNCTION__, size);
-
-	if (size < 1)
-		smclog(LOG_WARNING, errno, "%s: read() failed", __FUNCTION__);
+	/* sanity check */
+	if (client_sd < 0) {
+		errno = EBADFD;
+		return -1;
+	}
 
-	return size;
+	return read(client_sd, buf, len);
 }
 
-/*
-** Clean up IPC.
-** 
-*/
+/**
+ * ipc_exit - Tear down and cleanup IPC communication.
+ */
 void ipc_exit(void)
 {
-	if (server_sd) {
+	if (server_sd >= 0) {
 		close(server_sd);
 		unlink(SOCKET_PATH);
 	}
diff -urN smcroute-1.99.2/src/Makefile.in smcroute/src/Makefile.in
--- smcroute-1.99.2/src/Makefile.in	2013-07-16 06:59:37.000000000 +0200
+++ smcroute/src/Makefile.in	2014-06-30 12:22:34.845800674 +0200
@@ -7,6 +7,7 @@
 OBJS          = $(MCSENDER_OBJS) $(SMCROUTE_OBJS)
 SRCS          = $(OBJS:.o=.c)
 DEPS          = $(addprefix .,$(SRCS:.c=.d))
+LDLIBS        = @LIBS@
 
 # Smart autodependecy generation via GCC -M.
 .%.d: %.c
@@ -47,6 +48,9 @@
 	@printf "  LINK    $@\n"
 	@$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(SMCROUTE_OBJS) $(LDLIBS)
 
+check:
+	$(CHECK) $(CHECK_FLAGS) $(CPPFLAGS) $(SRCS)
+
 clean:
 	-@$(RM) build.h $(SMCROUTE_OBJS) $(MCSENDER_OBJS) $(EXECS)
 
diff -urN smcroute-1.99.2/src/_mcclient.c smcroute/src/_mcclient.c
--- smcroute-1.99.2/src/_mcclient.c	2013-07-16 06:59:37.000000000 +0200
+++ smcroute/src/_mcclient.c	2014-06-30 12:22:34.845800674 +0200
@@ -1,27 +1,25 @@
-/*
-**  smcroute - static multicast routing control 
-**  Copyright (C) 2001-2005 Carsten Schill <carsten@cschill.de>
-**  Copyright (C) 2006 Julien BLACHE <jb@jblache.org>
-**
-**  This program is free software; you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation; either version 2 of the License, or
-**  (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
-**
-**  $Id: _mcclient.c 17 2006-06-24 12:34:30Z jblache $
-**
-**  Multicast test tool
-**
-*/
+/* Multicast test tool
+ *
+ * Copyright (C) 2001-2005  Carsten Schill <carsten@cschill.de>
+ * Copyright (C) 2006-2009  Julien BLACHE <jb@jblache.org>
+ * Copyright (C) 2009       Todd Hayton <todd.hayton@gmail.com>
+ * Copyright (C) 2009-2011  Micha Lenk <micha@debian.org>
+ * Copyright (C) 2011-2013  Joachim Nilsson <troglobit@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ */
 
 #include "mclab.h"
 
diff -urN smcroute-1.99.2/src/mcgroup.c smcroute/src/mcgroup.c
--- smcroute-1.99.2/src/mcgroup.c	2013-07-16 06:59:37.000000000 +0200
+++ smcroute/src/mcgroup.c	2014-06-30 12:22:34.849800512 +0200
@@ -1,56 +1,57 @@
-/*
-**  smcroute - static multicast routing control 
-**  Copyright (C) 2001-2005 Carsten Schill <carsten@cschill.de>
-**  Copyright (C) 2006-2009 Julien BLACHE <jb@jblache.org>
-**  Copyright (C) 2009      Todd Hayton <todd.hayton@gmail.com>
-**
-**  This program is free software; you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation; either version 2 of the License, or
-**  (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
-**
-**  $Id: mcgroup.c 85 2011-08-08 16:47:53Z micha $	
-**
-**  This module contains the remaining functions that where not placed in 
-**  separate modules
-**
-*/
+/* Multicast group management (join/leave) API
+ *
+ * Copyright (C) 2001-2005  Carsten Schill <carsten@cschill.de>
+ * Copyright (C) 2006-2009  Julien BLACHE <jb@jblache.org>
+ * Copyright (C) 2009       Todd Hayton <todd.hayton@gmail.com>
+ * Copyright (C) 2009-2011  Micha Lenk <micha@debian.org>
+ * Copyright (C) 2011-2013  Joachim Nilsson <troglobit@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ */
 
 #include "mclab.h"
 
 static int mcgroup4_socket = -1;
 
+static struct iface *find_valid_iface(const char *ifname, int cmd)
+{
+	const char *command = cmd == 'j' ? "Join" : "Leave";
+	struct iface *iface = iface_find_by_name(ifname);
+
+	if (!iface) {
+		smclog(LOG_WARNING, 0, "%s multicast group, unknown interface %s", command, ifname);
+		return NULL;
+	}
+
+	return iface;
+}
+
 static void mcgroup4_init(void)
 {
-	if (mcgroup4_socket < 0) {
+	if (mcgroup4_socket < 0)
 		mcgroup4_socket = udp_socket_open(INADDR_ANY, 0);
-	}
 }
 
 static int mcgroup_join_leave_ipv4(int sd, int cmd, const char *ifname, struct in_addr group)
 {
 	int joinleave = cmd == 'j' ? IP_ADD_MEMBERSHIP : IP_DROP_MEMBERSHIP;
-	char buf[INET_ADDRSTRLEN];
-	const char *command = cmd == 'j' ? "Join" : "Leave";
 	struct ip_mreq mreq;
-	struct iface *iface = iface_find_by_name(ifname);
+	struct iface *iface = find_valid_iface(ifname, cmd);
 
-	if (!iface) {
-		smclog(LOG_WARNING, 0, "%s multicast group, unknown interface %s", command, ifname);
+	if (!iface)
 		return 1;
-	}
-
-	smclog(LOG_NOTICE, 0, "%s multicast group: %s on %s", command,
-	       inet_ntop(AF_INET, &group, buf, sizeof(buf)), iface ? iface->name : "<any>");
 
 	mreq.imr_multiaddr.s_addr = group.s_addr;
 	mreq.imr_interface.s_addr = iface->inaddr.s_addr;
@@ -64,13 +65,13 @@
 }
 
 /*
-** Joins the MC group with the address 'group' on the interface 'ifname'. 
-** The join is bound to the UDP socket 'sd', so if this socket is 
-** closed the membership is dropped.
-**          
-** returns: - 0 if the function succeeds
-**          - 1 if parameters are wrong or the join fails
-*/
+ * Joins the MC group with the address 'group' on the interface 'ifname'.
+ * The join is bound to the UDP socket 'sd', so if this socket is
+ * closed the membership is dropped.
+ *
+ * returns: - 0 if the function succeeds
+ *          - 1 if parameters are wrong or the join fails
+ */
 int mcgroup4_join(const char *ifname, struct in_addr group)
 {
 	mcgroup4_init();
@@ -79,11 +80,11 @@
 }
 
 /*
-** Leaves the MC group with the address 'group' on the interface 'ifname'. 
-**          
-** returns: - 0 if the function succeeds
-**          - 1 if parameters are wrong or the join fails
-*/
+ * Leaves the MC group with the address 'group' on the interface 'ifname'.
+ *
+ * returns: - 0 if the function succeeds
+ *          - 1 if parameters are wrong or the join fails
+ */
 int mcgroup4_leave(const char *ifname, struct in_addr group)
 {
 	mcgroup4_init();
@@ -92,8 +93,8 @@
 }
 
 /*
-** Close IPv4 multicast socket to kernel to leave any joined groups
-*/
+ * Close IPv4 multicast socket to kernel to leave any joined groups
+ */
 void mcgroup4_disable(void)
 {
 	if (mcgroup4_socket != -1) {
@@ -117,18 +118,11 @@
 static int mcgroup_join_leave_ipv6(int sd, int cmd, const char *ifname, struct in6_addr group)
 {
 	int joinleave = cmd == 'j' ? IPV6_JOIN_GROUP : IPV6_LEAVE_GROUP;
-	char buf[INET6_ADDRSTRLEN];
-	const char *command = cmd == 'j' ? "Join" : "Leave";
 	struct ipv6_mreq mreq;
-	struct iface *iface = iface_find_by_name(ifname);
+	struct iface *iface = find_valid_iface(ifname, cmd);
 
-	if (!iface) {
-		smclog(LOG_WARNING, 0, "%s multicast group, unknown interface %s", command, ifname);
+	if (!iface)
 		return 1;
-	}
-
-	smclog(LOG_NOTICE, 0, "%s multicast group: %s on %s", command,
-	       inet_ntop(AF_INET6, &group, buf, sizeof(buf)), iface ? iface->name : "<any>");
 
 	mreq.ipv6mr_multiaddr = group;
 	mreq.ipv6mr_interface = iface->ifindex;
@@ -142,13 +136,13 @@
 }
 
 /*
-** Joins the MC group with the address 'group' on the interface 'ifname'.
-** The join is bound to the UDP socket 'sd', so if this socket is
-** closed the membership is dropped.
-**
-** returns: - 0 if the function succeeds
-**          - 1 if parameters are wrong or the join fails
-*/
+ * Joins the MC group with the address 'group' on the interface 'ifname'.
+ * The join is bound to the UDP socket 'sd', so if this socket is
+ * closed the membership is dropped.
+ *
+ * returns: - 0 if the function succeeds
+ *          - 1 if parameters are wrong or the join fails
+ */
 int mcgroup6_join(const char *ifname, struct in6_addr group)
 {
 	mcgroup6_init();
@@ -157,11 +151,11 @@
 }
 
 /*
-** Leaves the MC group with the address 'group' on the interface 'ifname'.
-**
-** returns: - 0 if the function succeeds
-**          - 1 if parameters are wrong or the join fails
-*/
+ * Leaves the MC group with the address 'group' on the interface 'ifname'.
+ *
+ * returns: - 0 if the function succeeds
+ *          - 1 if parameters are wrong or the join fails
+ */
 int mcgroup6_leave(const char *ifname, struct in6_addr group)
 {
 	mcgroup6_init();
@@ -171,8 +165,8 @@
 #endif /* HAVE_IPV6_MULTICAST_HOST */
 
 /*
-** Close IPv6 multicast socket to kernel to leave any joined groups
-*/
+ * Close IPv6 multicast socket to kernel to leave any joined groups
+ */
 void mcgroup6_disable(void)
 {
 #ifdef HAVE_IPV6_MULTICAST_HOST
diff -urN smcroute-1.99.2/src/mclab.h smcroute/src/mclab.h
--- smcroute-1.99.2/src/mclab.h	2013-07-16 06:59:37.000000000 +0200
+++ smcroute/src/mclab.h	2014-06-30 12:22:34.849800512 +0200
@@ -1,27 +1,25 @@
-/*
-**  smcroute - static multicast routing control 
-**  Copyright (C) 2001-2005 Carsten Schill <carsten@cschill.de>
-**  Copyright (C) 2006-2009 Julien BLACHE <jb@jblache.org>
-**  Copyright (C) 2009      Todd Hayton <todd.hayton@gmail.com>
-**  Copyright (C) 2009-2011 Micha Lenk <micha@debian.org>
-**
-**  This program is free software; you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation; either version 2 of the License, or
-**  (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
-**
-**  $Id: mclab.h,v 1.7 2002/07/07 19:39:28 cschill Exp $	
-**
-*/
+/* Common include file
+ *
+ * Copyright (C) 2001-2005  Carsten Schill <carsten@cschill.de>
+ * Copyright (C) 2006-2009  Julien BLACHE <jb@jblache.org>
+ * Copyright (C) 2009       Todd Hayton <todd.hayton@gmail.com>
+ * Copyright (C) 2009-2011  Micha Lenk <micha@debian.org>
+ * Copyright (C) 2011-2013  Joachim Nilsson <troglobit@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ */
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -87,7 +85,7 @@
 #define MAX(a, b) ((a) < (b) ? (b) : (a))
 #endif
 
-/* http://stackoverflow.com/questions/1598773/is-there-a-standard-function-in-c-that-would-return-the-length-of-an-array/1598827#1598827 
+/* http://stackoverflow.com/questions/1598773/is-there-a-standard-function-in-c-that-would-return-the-length-of-an-array/1598827#1598827
  * Evidently Google uses it in Chromium.  It is actually intended to look like 0[arr], read the link, or search the web.
  */
 #define ARRAY_ELEMENTS(arr) ((sizeof(arr)/sizeof(0[arr])) / ((size_t)(!(sizeof(arr) % sizeof(0[arr])))))
@@ -150,7 +148,7 @@
 typedef struct mroute6 mroute6_t;
 
 /*
- * Generic multicast route (wrapper for IPv4/IPv6 mroute) 
+ * Generic multicast route (wrapper for IPv4/IPv6 mroute)
  */
 struct mroute {
 	int version;		/* 4 or 6 */
@@ -161,7 +159,7 @@
 };
 typedef struct mroute mroute_t;
 
-/* 
+/*
  * Raw IGMP socket used as interface for the IPv4 mrouted API.
  * Receives IGMP packets and upcall messages from the kernel.
  */
diff -urN smcroute-1.99.2/src/mcsender.c smcroute/src/mcsender.c
--- smcroute-1.99.2/src/mcsender.c	2013-07-16 06:59:37.000000000 +0200
+++ smcroute/src/mcsender.c	2014-06-30 12:22:34.849800512 +0200
@@ -1,28 +1,25 @@
-/*
-**  smcroute - static multicast routing control 
-**  Copyright (C) 2001-2005 Carsten Schill <carsten@cschill.de>
-**  Copyright (C) 2006-2008 Julien BLACHE <jb@jblache.org>
-**  Copyright (C) 2009      Todd Hayton <todd.hayton@gmail.com>
-**
-**  This program is free software; you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation; either version 2 of the License, or
-**  (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
-**
-**  $Id: mcsender.c 91 2011-08-08 18:46:43Z micha $
-**
-**  Multicast test tool
-**
-*/
+/* Multicast test tool
+ *
+ * Copyright (C) 2001-2005  Carsten Schill <carsten@cschill.de>
+ * Copyright (C) 2006-2009  Julien BLACHE <jb@jblache.org>
+ * Copyright (C) 2009       Todd Hayton <todd.hayton@gmail.com>
+ * Copyright (C) 2009-2011  Micha Lenk <micha@debian.org>
+ * Copyright (C) 2011-2013  Joachim Nilsson <troglobit@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ */
 
 #include <stdio.h>
 #include <string.h>
@@ -32,8 +29,8 @@
 
 int do_debug_logging = 0;
 
-const char Usage[] = "mcsender [-t<n>] [-i<ifname>] <ip-address:port>\n";
-const char McMsg[] = "this is the test message from mclab/mcsender\n";
+static const char Usage[] = "mcsender [-t<n>] [-i<ifname>] <ip-address:port>\n";
+static const char McMsg[] = "this is the test message from mclab/mcsender\n";
 
 static void usage(void);
 
@@ -74,7 +71,7 @@
 				break;
 
 			case 't':
-				if (sscanf(Pt + 1, " %u", &TtlVal) != 1 || TtlVal < 1) {
+				if (sscanf(Pt + 1, " %3u", &TtlVal) != 1 || TtlVal < 1) {
 					usage();
 					exit(1);
 				}
@@ -190,14 +187,14 @@
 }
 
 /*
-** Converts the internet address plus port string in 'St' 
-** into their network byte order representations.
-**
-** returns: - 0 -> conversion failed
-**          - 1 -> only address part returned (inaddrPt)
-**          - 2 -> address and port returned
-**          
-*/
+ * Converts the internet address plus port string in 'St'
+ * into their network byte order representations.
+ *
+ * returns: - 0 -> conversion failed
+ *          - 1 -> only address part returned (inaddrPt)
+ *          - 2 -> address and port returned
+ *
+ */
 static void getSockAdr(struct sockaddr *SaPt, socklen_t * SaLenPt, char *AddrSt, char *PortSt)
 {
 	struct sockaddr_in *Sin4;
diff -urN smcroute-1.99.2/src/mroute-api.c smcroute/src/mroute-api.c
--- smcroute-1.99.2/src/mroute-api.c	2013-07-16 06:59:37.000000000 +0200
+++ smcroute/src/mroute-api.c	2014-06-30 12:22:34.849800512 +0200
@@ -1,29 +1,25 @@
-/*
-**  smcroute - static multicast routing control 
-**  Copyright (C) 2001-2005 Carsten Schill <carsten@cschill.de>
-**  Copyright (C) 2006-2009 Julien BLACHE <jb@jblache.org>
-**  Copyright (C) 2009      Todd Hayton <todd.hayton@gmail.com>
-**  Copyright (C) 2009-2011 Micha Lenk <micha@debian.org>
-**
-**  This program is free software; you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation; either version 2 of the License, or
-**  (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
-**
-**  $Id: mroute-api.c 85 2011-08-08 16:47:53Z micha $	
-**
-**  This module contains the interface routines to the Linux mrouted API
-**
-*/
+/* Generic kernel multicast routing API for Linux/*BSD
+ *
+ * Copyright (C) 2001-2005  Carsten Schill <carsten@cschill.de>
+ * Copyright (C) 2006-2009  Julien BLACHE <jb@jblache.org>
+ * Copyright (C) 2009       Todd Hayton <todd.hayton@gmail.com>
+ * Copyright (C) 2009-2011  Micha Lenk <micha@debian.org>
+ * Copyright (C) 2011-2013  Joachim Nilsson <troglobit@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ */
 #include <unistd.h>
 #include <arpa/inet.h>
 #include "config.h"
@@ -35,16 +31,19 @@
 
 /* MAX_MC_VIFS from mclab.h must have same value as MAXVIFS from mroute.h */
 #if MAX_MC_VIFS != MAXVIFS
-#error "constants don't match, correct mclab.h"
+#error "IPv4 constants don't match, mclab.h needs to be fixed!"
 #endif
 
 #ifdef HAVE_IPV6_MULTICAST_ROUTING
 /* MAX_MC_MIFS from mclab.h must have same value as MAXVIFS from mroute6.h */
 #if MAX_MC_MIFS != MAXMIFS
-#error "constants don't match, correct mclab.h"
+#error "IPv6 constants don't match, mclab.h needs to be fixed!"
 #endif
 #endif
 
+/* Used for (*,G) matches */
+#define mroute4_match(r1, r2) (!memcmp(&(r1)->group, &(r2)->group, sizeof((r1)->group)) && (r1)->inbound == (r2)->inbound)
+
 /*
  * Need a raw IGMP socket as interface for the IPv4 mrouted API
  * Receives IGMP packets and kernel upcall messages.
@@ -73,7 +72,7 @@
 	struct iface *iface;
 } vif_list[MAXVIFS];
 
-static void mroute4_add_vif(struct iface *iface);
+static int mroute4_add_vif(struct iface *iface);
 
 #ifdef HAVE_IPV6_MULTICAST_ROUTING
 /* IPv6 internal virtual interfaces (VIF) descriptor vector */
@@ -81,16 +80,18 @@
 	struct iface *iface;
 } mif_list[MAXMIFS];
 
-static void mroute6_add_mif(struct iface *iface);
+static int mroute6_add_mif(struct iface *iface);
 #endif
 
-/*
-** Initialise the mrouted API and locks the multicast routing
-** socket to this program (only!).
-**     
-** returns: - 0 if the functions succeeds     
-**          - the errno value for non-fatal failure condition
-*/
+/**
+ * mroute4_enable - Initialise IPv4 multicast routing
+ *
+ * Setup the kernel IPv4 multicast routing API and lock the multicast
+ * routing socket to this program (only!).
+ *
+ * Returns:
+ * POSIX OK(0) on success, non-zero on error with @errno set.
+ */
 int mroute4_enable(void)
 {
 	int arg = 1;
@@ -100,7 +101,7 @@
 	mroute4_socket = socket(AF_INET, SOCK_RAW, IPPROTO_IGMP);
 	if (mroute4_socket < 0) {
 		if (ENOPROTOOPT == errno)
-			smclog(LOG_WARNING, 0, "Kernel does not support IPv4 multicast routing, skipping...");
+			smclog(LOG_WARNING, 0, "Kernel does not support IPv4 multicast routing, skipping ...");
 
 		return -1;
 	}
@@ -111,12 +112,6 @@
 			smclog(LOG_INIT, errno, "IPv4 multicast routing API already in use");
 			break;
 
-#ifdef EOPNOTSUPP
-		case EOPNOTSUPP:
-			smclog(LOG_INIT, errno, "Unknown socket option MRT_INIT");
-			break;
-#endif
-
 		default:
 			smclog(LOG_INIT, errno, "Failed initializing IPv4 multicast routing API");
 			break;
@@ -139,7 +134,10 @@
 			iface->vif = -1;
 			continue;
 		}
-		mroute4_add_vif(iface);
+
+		/* No point in continuing the loop when out of VIF's */
+		if (mroute4_add_vif(iface))
+			break;
 	}
 
 	LIST_INIT(&mroute4_conf_list);
@@ -148,9 +146,11 @@
 	return 0;
 }
 
-/*
-** Diable the mrouted API and relase the kernel lock.
-*/
+/**
+ * mroute4_disable - Disable IPv4 multicast routing
+ *
+ * Disable IPv4 multicast routing and release kernel routing socket.
+ */
 void mroute4_disable(void)
 {
 	mroute4_t *entry;
@@ -159,9 +159,7 @@
 		return;
 
 	/* Drop all kernel routes set by smcroute */
-	if (setsockopt(mroute4_socket, IPPROTO_IP, MRT_DONE, NULL, 0))
-		smclog(LOG_ERR, errno, "MRT_DONE");
-
+	setsockopt(mroute4_socket, IPPROTO_IP, MRT_DONE, NULL, 0);
 	close(mroute4_socket);
 	mroute4_socket = -1;
 
@@ -179,14 +177,11 @@
 }
 
 
-/*
-** Adds the interface '*iface' as virtual interface to the mrouted API
-*/
-static void mroute4_add_vif(struct iface *iface)
+/* Create a virtual interface from @iface so it can be used for IPv4 multicast routing. */
+static int mroute4_add_vif(struct iface *iface)
 {
 	struct vifctl vc;
 	int vif = -1;
-	char buf[16];
 	size_t i;
 
 	/* search free vif */
@@ -199,8 +194,8 @@
 
 	/* no more space */
 	if (vif == -1) {
-		smclog(LOG_ERR, ENOMEM, "%s: out of VIF space", __FUNCTION__);
-		return;
+		smclog(LOG_WARNING, ENOMEM, "Kernel MAXVIFS (%d) too small for number of interfaces", MAXVIFS);
+		return 1;
 	}
 
 	memset(&vc, 0, sizeof(vc));
@@ -211,21 +206,20 @@
 	vc.vifc_lcl_addr.s_addr = iface->inaddr.s_addr;
 	vc.vifc_rmt_addr.s_addr = INADDR_ANY;
 
-	smclog(LOG_NOTICE, 0, "Add VIF: %d Ifindex: %d Flags: 0x%04x IP: %s Ifname: %s",
-	       vc.vifc_vifi, iface->ifindex, vc.vifc_flags,
-	       inet_ntop (AF_INET, &vc.vifc_lcl_addr, buf, sizeof(buf)),
-	       iface->name);
-
-	if (setsockopt(mroute4_socket, IPPROTO_IP, MRT_ADD_VIF, (void *)&vc, sizeof(vc))) {
-		smclog(LOG_ERR, errno, "MRT_ADD_VIF %s", iface->name);
-	} else {
-		iface->vif = vif;
-		vif_list[vif].iface = iface;
-	}
+	smclog(LOG_DEBUG, 0, "Iface %s => VIF %d index %d flags 0x%04x",
+	       iface->name, vc.vifc_vifi, iface->ifindex, vc.vifc_flags);
+
+	if (setsockopt(mroute4_socket, IPPROTO_IP, MRT_ADD_VIF, (void *)&vc, sizeof(vc)))
+		smclog(LOG_ERR, errno, "Failed adding VIF for iface %s", iface->name);
+
+	iface->vif = vif;
+	vif_list[vif].iface = iface;
+
+	return 0;
 }
 
 /* Actually set in kernel - called by mroute4_add() and mroute4_check_add() */
-static int __mroute4_add (mroute4_t *ptr)
+static int __mroute4_add (mroute4_t *route)
 {
 	int result = 0;
 	char origin[INET_ADDRSTRLEN], group[INET_ADDRSTRLEN];
@@ -233,68 +227,67 @@
 
 	memset(&mc, 0, sizeof(mc));
 
-	mc.mfcc_origin = ptr->sender;
-	mc.mfcc_mcastgrp = ptr->group;
-	mc.mfcc_parent = ptr->inbound;
+	mc.mfcc_origin = route->sender;
+	mc.mfcc_mcastgrp = route->group;
+	mc.mfcc_parent = route->inbound;
 
 	/* copy the TTL vector */
-	if (sizeof(mc.mfcc_ttls[0]) != sizeof(ptr->ttl[0]) || ARRAY_ELEMENTS(mc.mfcc_ttls) != ARRAY_ELEMENTS(ptr->ttl))
-		smclog(LOG_ERR, 0, "Data types does not match in %s, source adaption needed!", __FILE__);
+	if (sizeof(mc.mfcc_ttls[0]) != sizeof(route->ttl[0]) || ARRAY_ELEMENTS(mc.mfcc_ttls) != ARRAY_ELEMENTS(route->ttl))
+		smclog(LOG_ERR, 0, "Critical data type validation error in %s!", __FILE__);
 
-	memcpy(mc.mfcc_ttls, ptr->ttl, ARRAY_ELEMENTS(mc.mfcc_ttls) * sizeof(mc.mfcc_ttls[0]));
+	memcpy(mc.mfcc_ttls, route->ttl, ARRAY_ELEMENTS(mc.mfcc_ttls) * sizeof(mc.mfcc_ttls[0]));
 
-	smclog(LOG_NOTICE, 0, "Add MFC: %s -> %s, inbound VIF: %d",
+	smclog(LOG_DEBUG, 0, "Add %s -> %s from VIF %d",
 	       inet_ntop(AF_INET, &mc.mfcc_origin,   origin, INET_ADDRSTRLEN),
 	       inet_ntop(AF_INET, &mc.mfcc_mcastgrp, group,  INET_ADDRSTRLEN), mc.mfcc_parent);
 
 	if (setsockopt(mroute4_socket, IPPROTO_IP, MRT_ADD_MFC, (void *)&mc, sizeof(mc))) {
 		result = errno;
-		smclog(LOG_WARNING, errno, "MRT_ADD_MFC");
+		smclog(LOG_WARNING, errno, "Failed adding IPv4 multicast route");
 	}
 
 	return result;
 }
 
 /* Actually remove from kernel - called by mroute4_del() */
-static int __mroute4_del (mroute4_t *ptr)
+static int __mroute4_del (mroute4_t *route)
 {
 	int result = 0;
 	char origin[INET_ADDRSTRLEN], group[INET_ADDRSTRLEN];
 	struct mfcctl mc;
 
 	memset(&mc, 0, sizeof(mc));
-	mc.mfcc_origin = ptr->sender;
-	mc.mfcc_mcastgrp = ptr->group;
+	mc.mfcc_origin = route->sender;
+	mc.mfcc_mcastgrp = route->group;
 
-	smclog(LOG_NOTICE, 0, "Del MFC: %s -> %s",
+	smclog(LOG_DEBUG, 0, "Del %s -> %s",
 	       inet_ntop(AF_INET, &mc.mfcc_origin,  origin, INET_ADDRSTRLEN),
 	       inet_ntop(AF_INET, &mc.mfcc_mcastgrp, group, INET_ADDRSTRLEN));
 
 	if (setsockopt(mroute4_socket, IPPROTO_IP, MRT_DEL_MFC, (void *)&mc, sizeof(mc))) {
 		result = errno;
-		smclog(LOG_WARNING, errno, "MRT_DEL_MFC");
+		smclog(LOG_WARNING, errno, "Failed removing IPv4 multicast route");
 	}
 
 	return result;
 }
 
-/*
-** Add mcroute to kernel if it matches a known (*,G) route.
-**
-** returns: - 0 if the function succeeds
-**          - the errno value for non-fatal failure condition
-*/
-int mroute4_dyn_add(mroute4_t *ptr)
+/**
+ * mroute4_dyn_add - Add route to kernel if it matches a known (*,G) route.
+ * @route: Pointer to candidate &mroute4_t IPv4 multicast route
+ *
+ * Returns:
+ * POSIX OK(0) on success, non-zero on error with @errno set.
+ */
+int mroute4_dyn_add(mroute4_t *route)
 {
 	mroute4_t *entry;
 
 	LIST_FOREACH(entry, &mroute4_conf_list, link) {
 		/* Find matching (*,G) ... and interface. */
-		if (!memcmp (&entry->group, &ptr->group, sizeof(entry->group)) && entry->inbound == ptr->inbound) {
-			smclog(LOG_DEBUG, 0, "Found (*,G) match for (0x%x, 0x%x)!", ptr->sender.s_addr, ptr->group.s_addr);
-
+		if (mroute4_match(entry, route)) {
 			/* Use configured template (*,G) outbound interfaces. */
-			memcpy(ptr->ttl, entry->ttl, ARRAY_ELEMENTS(ptr->ttl) * sizeof(ptr->ttl[0]));
+			memcpy(route->ttl, entry->ttl, ARRAY_ELEMENTS(route->ttl) * sizeof(route->ttl[0]));
 
 			/* Add to list of dynamically added routes. Necessary if the user
 			 * removes the (*,G) using the command line interface rather than
@@ -302,131 +295,139 @@
 			 * memory we don't do anything, just add kernel route silently. */
 			entry = malloc(sizeof(mroute4_t));
 			if (entry) {
-				memcpy(entry, ptr, sizeof(mroute4_t));
+				memcpy(entry, route, sizeof(mroute4_t));
 				LIST_INSERT_HEAD(&mroute4_dyn_list, entry, link);
 			}
 
-			return __mroute4_add(ptr);
+			return __mroute4_add(route);
 		}
 	}
 
-	smclog(LOG_DEBUG, 0, "No (*,G) match for (0x%x, 0x%x)!", ptr->sender.s_addr, ptr->group.s_addr);
-
 	errno = ENOENT;
 	return -1;
 }
 
-/*
-** Adds the multicast route '*ptr' to the kernel multicast routing table
-** unless the source IP is INADDR_ANY, i.e., a (*,G) route. Those we save
-** for later and check against at runtime when the kernel signals us.
-**
-** returns: - 0 if the function succeeds
-**          - the errno value for non-fatal failure condition
-*/
-int mroute4_add(mroute4_t *ptr)
+/**
+ * mroute4_add - Add route to kernel, or save a wildcard route for later use
+ * @route: Pointer to &mroute4_t IPv4 multicast route to add
+ *
+ * Adds the given multicast @route to the kernel multicast routing table
+ * unless the source IP is %INADDR_ANY, i.e., a (*,G) route.  Those we
+ * save for and check against at runtime when the kernel signals us.
+ *
+ * Returns:
+ * POSIX OK(0) on success, non-zero on error with @errno set.
+ */
+int mroute4_add(mroute4_t *route)
 {
 	/* For (*,G) we save to a linked list to be added on-demand
 	 * when the kernel sends IGMPMSG_NOCACHE. */
-	if (ptr->sender.s_addr == INADDR_ANY) {
+	if (route->sender.s_addr == INADDR_ANY) {
 		mroute4_t *entry = malloc(sizeof(mroute4_t));
 
 		if (!entry) {
-			smclog(LOG_WARNING, errno, "Failed allocating (*,G) entry to linked list");
+			smclog(LOG_WARNING, errno, "Failed adding (*,G) multicast route");
 			return errno;
 		}
 
-		memcpy(entry, ptr, sizeof(mroute4_t));
-		smclog(LOG_DEBUG, 0, "Adding (*,G) mroute to dynamic list => (0x%x, 0x%x) vif:%d ",
-		       ptr->sender.s_addr, ptr->group.s_addr, ptr->inbound);
+		memcpy(entry, route, sizeof(mroute4_t));
 		LIST_INSERT_HEAD(&mroute4_conf_list, entry, link);
 
 		return 0;
 	}
 
-	return __mroute4_add (ptr);
+	return __mroute4_add (route);
 }
 
-/*
-** Removes the multicast routed '*ptr' from the kernel routes
-**
-** returns: - 0 if the function succeeds
-**          - the errno value for non-fatal failure condition
-*/
-int mroute4_del(mroute4_t *ptr)
+/**
+ * mroute4_del - Remove route from kernel
+ * @route: Pointer to &mroute4_t IPv4 multicast route to remove
+ *
+ * Removes the given multicast @route from the kernel multicast routing
+ * table.
+ *
+ * Returns:
+ * POSIX OK(0) on success, non-zero on error with @errno set.
+ */
+int mroute4_del(mroute4_t *route)
 {
+	mroute4_t *entry, *set;
+
 	/* For (*,G) we have saved all dynamically added kernel routes
 	 * to a linked list which we need to traverse again and remove
 	 * all matches. From kernel dyn list before we remove the conf
 	 * entry. */
-	if (ptr->sender.s_addr == INADDR_ANY) {
-		mroute4_t *entry;
+	if (route->sender.s_addr != INADDR_ANY)
+		return __mroute4_del(route);
 
-		if (LIST_EMPTY(&mroute4_conf_list))
-			return 0;
+	if (LIST_EMPTY(&mroute4_conf_list))
+		return 0;
 
-		entry = LIST_FIRST(&mroute4_conf_list);
-		while (entry) {
-			smclog(LOG_DEBUG, 0, "%s:%d:%s:looping over entry at 0x%x", __FILE__, __LINE__, __func__, entry);
-			/* Find matching (*,G) ... and interface. */
-			if (!memcmp (&entry->group, &ptr->group, sizeof(entry->group)) && entry->inbound == ptr->inbound) {
-				mroute4_t *set;
-
-				smclog(LOG_DEBUG, 0, "Found (*,G) match for (0x%x, 0x%x) - now find any set routes!", ptr->sender.s_addr, ptr->group.s_addr);
-				if (LIST_EMPTY(&mroute4_dyn_list)) {
-					entry = LIST_NEXT(entry, link);
+	entry = LIST_FIRST(&mroute4_conf_list);
+	while (entry) {
+		/* Find matching (*,G) ... and interface. */
+		if (mroute4_match(entry, route)) {
+			if (LIST_EMPTY(&mroute4_dyn_list)) {
+				entry = LIST_NEXT(entry, link);
+				continue;
+			}
+
+			set = LIST_FIRST(&mroute4_dyn_list);
+			while (set) {
+				if (mroute4_match(entry, set)) {
+					__mroute4_del(set);
+					LIST_REMOVE(set, link);
+					free(set);
+
+					set = LIST_FIRST(&mroute4_dyn_list);
 					continue;
 				}
 
-				set = LIST_FIRST(&mroute4_dyn_list);
-				while (set) {
-					if (!memcmp (&entry->group, &set->group, sizeof(entry->group)) && entry->inbound == set->inbound) {
-						smclog(LOG_DEBUG, 0, "Found match (0x%x, 0x%x) - removing, unlinking and freeing.", set->sender.s_addr, set->group.s_addr);
-						__mroute4_del(set);
-						LIST_REMOVE(set, link);
-						free(set);
-						set = LIST_FIRST(&mroute4_dyn_list);
-					} else set = LIST_NEXT(set, link);
-				}
+				set = LIST_NEXT(set, link);
+			}
+
+			LIST_REMOVE(entry, link);
+			free(entry);
 
-				LIST_REMOVE(entry, link);
-				free(entry);
-				entry = LIST_FIRST(&mroute4_conf_list);
-			} else entry = LIST_NEXT(entry, link);
+			entry = LIST_FIRST(&mroute4_conf_list);
+			continue;
 		}
-	} else
-		return __mroute4_del(ptr);
-}
 
+		entry = LIST_NEXT(entry, link);
+	}
+
+	return 0;
+}
 
 #ifdef HAVE_IPV6_MULTICAST_ROUTING
 #define IPV6_ALL_MC_FORWARD "/proc/sys/net/ipv6/conf/all/mc_forwarding"
 
 static int proc_set_val(char *file, int val)
 {
-	int fd;
+	int fd, result = 0;
 
 	fd = open(file, O_WRONLY);
-	if (fd < 0) {
+	if (fd < 0)
 		return 1;
-	} else {
-		if (-1 == write(fd, "1", val)) {
-			(void)close(fd);
-			return 1;
-		}
-		(void)close(fd);
-	}
 
-	return 0;
+	if (-1 == write(fd, "1", val))
+		result = 1;
+
+	close(fd);
+
+	return result;
 }
 #endif /* HAVE_IPV6_MULTICAST_ROUTING */
 
-/*
-** Initialises the mrouted API and locks it by this exclusively.
-**     
-** returns: - 0 if the functions succeeds     
-**          - the errno value for non-fatal failure condition
-*/
+/**
+ * mroute6_enable - Initialise IPv6 multicast routing
+ *
+ * Setup the kernel IPv6 multicast routing API and lock the multicast
+ * routing socket to this program (only!).
+ *
+ * Returns:
+ * POSIX OK(0) on success, non-zero on error with @errno set.
+ */
 int mroute6_enable(void)
 {
 #ifndef HAVE_IPV6_MULTICAST_ROUTING
@@ -438,7 +439,7 @@
 
 	if ((mroute6_socket = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6)) < 0) {
 		if (ENOPROTOOPT == errno)
-			smclog(LOG_WARNING, 0, "Kernel does not support IPv6 multicast routing, skipping...");
+			smclog(LOG_WARNING, 0, "Kernel does not support IPv6 multicast routing, skipping ...");
 
 		return -1;
 	}
@@ -448,12 +449,6 @@
 			smclog(LOG_INIT, errno, "IPv6 multicast routing API already in use");
 			break;
 
-#ifdef EOPNOTSUPP
-		case EOPNOTSUPP:
-			smclog(LOG_INIT, errno, "Unknown socket option MRT6_INIT");
-			break;
-#endif
-
 		default:
 			smclog(LOG_INIT, errno, "Failed initializing IPv6 multicast routing API");
 			break;
@@ -472,45 +467,45 @@
 	 * is not set on MRT6_INIT so we have to do this manually */
 	if (proc_set_val(IPV6_ALL_MC_FORWARD, 1)) {
 		if (errno != EACCES)
-			smclog(LOG_ERR, errno, "Failed enabling IPv6 mc_forwarding");
+			smclog(LOG_ERR, errno, "Failed enabling IPv6 multicast forwarding");
 	}
 
-	/* create MIFs for all IP, non-loop interfaces */
+	/* Create virtual interfaces, IPv6 MIFs, for all non-loopback interfaces */
 	for (i = 0; (iface = iface_find_by_index(i)); i++) {
 		if (iface->flags & IFF_LOOPBACK) {
 			iface->vif = -1;
 			continue;
 		}
-		mroute6_add_mif(iface);
+
+		/* No point in continuing the loop when out of MIF's */
+		if (mroute6_add_mif(iface))
+			break;
 	}
 
 	return 0;
 #endif /* HAVE_IPV6_MULTICAST_ROUTING */
 }
 
-/*
-** Diables the mrouted API and relases by this the lock.
-**          
-*/
+/**
+ * mroute6_disable - Disable IPv6 multicast routing
+ *
+ * Disable IPv6 multicast routing and release kernel routing socket.
+ */
 void mroute6_disable(void)
 {
 #ifdef HAVE_IPV6_MULTICAST_ROUTING
 	if (mroute6_socket < 0)
 		return;
 
-	if (setsockopt(mroute6_socket, IPPROTO_IPV6, MRT6_DONE, NULL, 0))
-		smclog(LOG_ERR, errno, "MRT6_DONE");
-
+	setsockopt(mroute6_socket, IPPROTO_IPV6, MRT6_DONE, NULL, 0);
 	close(mroute6_socket);
 	mroute6_socket = -1;
 #endif /* HAVE_IPV6_MULTICAST_ROUTING */
 }
 
 #ifdef HAVE_IPV6_MULTICAST_ROUTING
-/*
-** Adds the interface '*iface' as virtual interface to the mrouted API
-*/
-static void mroute6_add_mif(struct iface *iface)
+/* Create a virtual interface from @iface so it can be used for IPv6 multicast routing. */
+static int mroute6_add_mif(struct iface *iface)
 {
 	struct mif6ctl mc;
 	int mif = -1;
@@ -526,8 +521,8 @@
 
 	/* no more space */
 	if (mif == -1) {
-		smclog(LOG_ERR, ENOMEM, "%s: out of MIF space", __FUNCTION__);
-		return;
+		smclog(LOG_WARNING, ENOMEM, "Kernel MAXMIFS (%d) too small for number of interfaces", MAXMIFS);
+		return 1;
 	}
 
 	memset(&mc, 0, sizeof(mc));
@@ -541,24 +536,28 @@
 	mc.vifc_rate_limit = 0;	/* hopefully no limit */
 #endif
 
-	smclog(LOG_NOTICE, 0, "Add MIF: %d Ifindex: %d Flags: 0x%04x Ifname: %s",
-	       mc.mif6c_mifi, mc.mif6c_pifi, mc.mif6c_flags, iface->name);
+	smclog(LOG_DEBUG, 0, "Iface %s => MIF %d index %d flags 0x%04x",
+	       iface->name, mc.mif6c_mifi, mc.mif6c_pifi, mc.mif6c_flags);
 
-	if (setsockopt(mroute6_socket, IPPROTO_IPV6, MRT6_ADD_MIF, (void *)&mc, sizeof(mc))) {
-		smclog(LOG_ERR, errno, "MRT6_ADD_MIF %s", iface->name);
-	} else {
-		iface->mif = mif;
-		mif_list[mif].iface = iface;
-	}
+	if (setsockopt(mroute6_socket, IPPROTO_IPV6, MRT6_ADD_MIF, (void *)&mc, sizeof(mc)))
+		smclog(LOG_ERR, errno, "Failed adding MIF for iface %s", iface->name);
+
+	iface->mif = mif;
+	mif_list[mif].iface = iface;
+
+	return 0;
 }
 
-/*
-** Adds the multicast routed '*ptr' to the kernel routes
-**
-** returns: - 0 if the function succeeds
-**          - the errno value for non-fatal failure condition
-*/
-int mroute6_add(mroute6_t *ptr)
+/**
+ * mroute6_add - Add route to kernel, or save a wildcard route for later use
+ * @route: Pointer to &mroute6_t IPv6 multicast route to add
+ *
+ * Adds the given multicast @route to the kernel multicast routing table.
+ *
+ * Returns:
+ * POSIX OK(0) on success, non-zero on error with @errno set.
+ */
+int mroute6_add(mroute6_t *route)
 {
 	int result = 0;
 	size_t i;
@@ -566,55 +565,56 @@
 	struct mf6cctl mc;
 
 	memset(&mc, 0, sizeof(mc));
-	mc.mf6cc_origin   = ptr->sender;
-	mc.mf6cc_mcastgrp = ptr->group;
-	mc.mf6cc_parent   = ptr->inbound;
+	mc.mf6cc_origin   = route->sender;
+	mc.mf6cc_mcastgrp = route->group;
+	mc.mf6cc_parent   = route->inbound;
 
 	/* copy the outgoing MIFs */
-	for (i = 0; i < ARRAY_ELEMENTS(ptr->ttl); i++) {
-		if (ptr->ttl[i] > 0)
+	for (i = 0; i < ARRAY_ELEMENTS(route->ttl); i++) {
+		if (route->ttl[i] > 0)
 			IF_SET(i, &mc.mf6cc_ifset);
 	}
 
-	smclog(LOG_NOTICE, 0, "Add MFC: %s -> %s, Inbound MIF: %d",
-	       inet_ntop(AF_INET6, &mc.mf6cc_origin.sin6_addr,
-			 origin, INET6_ADDRSTRLEN),
-	       inet_ntop(AF_INET6, &mc.mf6cc_mcastgrp.sin6_addr,
-			 group, INET6_ADDRSTRLEN), mc.mf6cc_parent);
+	smclog(LOG_DEBUG, 0, "Add %s -> %s from MIF %d",
+	       inet_ntop(AF_INET6, &mc.mf6cc_origin.sin6_addr, origin, INET6_ADDRSTRLEN),
+	       inet_ntop(AF_INET6, &mc.mf6cc_mcastgrp.sin6_addr, group, INET6_ADDRSTRLEN),
+	       mc.mf6cc_parent);
 
 	if (setsockopt(mroute6_socket, IPPROTO_IPV6, MRT6_ADD_MFC, (void *)&mc, sizeof(mc))) {
 		result = errno;
-		smclog(LOG_WARNING, errno, "MRT6_ADD_MFC");
+		smclog(LOG_WARNING, errno, "Failed adding IPv6 multicast route");
 	}
 
 	return result;
 }
 
-/*
-** Removes the multicast routed '*ptr' from the kernel routes
-**
-** returns: - 0 if the function succeeds
-**          - the errno value for non-fatal failure condition
-*/
-int mroute6_del(mroute6_t *ptr)
+/**
+ * mroute6_del - Remove route from kernel
+ * @route: Pointer to &mroute6_t IPv6 multicast route to remove
+ *
+ * Removes the given multicast @route from the kernel multicast routing
+ * table.
+ *
+ * Returns:
+ * POSIX OK(0) on success, non-zero on error with @errno set.
+ */
+int mroute6_del(mroute6_t *route)
 {
 	int result = 0;
 	char origin[INET_ADDRSTRLEN], group[INET_ADDRSTRLEN];
 	struct mf6cctl mc;
 
 	memset(&mc, 0, sizeof(mc));
-	mc.mf6cc_origin = ptr->sender;
-	mc.mf6cc_mcastgrp = ptr->group;
+	mc.mf6cc_origin = route->sender;
+	mc.mf6cc_mcastgrp = route->group;
 
-	smclog(LOG_NOTICE, 0, "Del MFC: %s -> %s",
-	       inet_ntop(AF_INET6, &mc.mf6cc_origin.sin6_addr,
-			 origin, INET6_ADDRSTRLEN),
-	       inet_ntop(AF_INET6, &mc.mf6cc_mcastgrp.sin6_addr,
-			 group, INET6_ADDRSTRLEN));
+	smclog(LOG_DEBUG, 0, "Del %s -> %s",
+	       inet_ntop(AF_INET6, &mc.mf6cc_origin.sin6_addr, origin, INET6_ADDRSTRLEN),
+	       inet_ntop(AF_INET6, &mc.mf6cc_mcastgrp.sin6_addr, group, INET6_ADDRSTRLEN));
 
 	if (setsockopt(mroute6_socket, IPPROTO_IPV6, MRT6_DEL_MFC, (void *)&mc, sizeof(mc))) {
 		result = errno;
-		smclog(LOG_WARNING, errno, "MRT_DEL_MFC");
+		smclog(LOG_WARNING, errno, "Failed removing IPv6 multicast route");
 	}
 
 	return result;
diff -urN smcroute-1.99.2/src/parse-conf.c smcroute/src/parse-conf.c
--- smcroute-1.99.2/src/parse-conf.c	2013-07-16 06:59:37.000000000 +0200
+++ smcroute/src/parse-conf.c	2014-06-30 12:22:34.849800512 +0200
@@ -1,6 +1,6 @@
 /* Simple .conf file parser for smcroute
  *
- * Copyright (c) 2011  Joachim Nilsson <troglobit@gmail.com>
+ * Copyright (c) 2011-2013  Joachim Nilsson <troglobit@gmail.com>
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -27,9 +27,13 @@
 
 static char *pop_token(char **line)
 {
-	char *end, *token = *line;
+	char *end, *token;
 
-	if (!line || !token)
+	if (!line)
+		return NULL;
+
+	token = *line;
+	if (!token)
 		return NULL;
 
 	/* Find start of token, skip whitespace. */
@@ -74,13 +78,13 @@
 
 	if (strchr(group, ':')) {
 #if !defined(HAVE_IPV6_MULTICAST_HOST) || !defined(HAVE_IPV6_MULTICAST_ROUTING)
-		smclog(LOG_WARNING, 0, "Line %02: Sadly this build of smcroute does not support IPv6.", lineno);
+		smclog(LOG_WARNING, 0, "%02: Ignored, IPv6 disabled.", lineno);
 		result = 0;
 #else
 		struct in6_addr grp;
 
 		if (inet_pton(AF_INET6, group, &grp) <= 0 || !IN6_IS_ADDR_MULTICAST(&grp)) {
-			smclog(LOG_WARNING, 0, "Line %02d: invalid IPv6 multicast group address: %s", lineno, group);
+			smclog(LOG_WARNING, 0, "%02d: Invalid IPv6 multicast group: %s", lineno, group);
 			return 1;
 		}
 
@@ -90,7 +94,7 @@
 		struct in_addr grp;
 
 		if ((inet_pton(AF_INET, group, &grp) <= 0) || !IN_MULTICAST(ntohl(grp.s_addr))) {
-			smclog(LOG_WARNING, 0, "Line %02d: invalid IPv4 multicast group address: %s", lineno, group);
+			smclog(LOG_WARNING, 0, "%02d: Invalid IPv4 multicast group: %s", lineno, group);
 			return 1;
 		}
 
@@ -111,23 +115,23 @@
 
 	if (strchr(group, ':')) {
 #if !defined(HAVE_IPV6_MULTICAST_HOST) || !defined(HAVE_IPV6_MULTICAST_ROUTING)
-		smclog(LOG_WARNING, 0, "Line %02: Sadly this build of smcroute does not support IPv6.", lineno);
+		smclog(LOG_WARNING, 0, "%02: Ignored, IPv6 disabled.", lineno);
 		result = 0;
 #else
 		mroute6_t mroute;
 
 		mroute.inbound = iface_get_mif_by_name(ifname);
 		if (mroute.inbound < 0) {
-			smclog(LOG_WARNING, 0, "Line %02d: Invalid inbound IPv6 interface: %s", lineno, ifname);
+			smclog(LOG_WARNING, 0, "%02d: Invalid inbound IPv6 interface: %s", lineno, ifname);
 			return 1;
 		}
-		if (!source || inet_pton(AF_INET6, source, &mroute.sender) <= 0) {
-			smclog(LOG_WARNING, 0, "Line %02d: Invalid source IPv6 address: %s", lineno, source ?: "NONE");
+		if (!source || inet_pton(AF_INET6, source, &mroute.sender.sin6_addr) <= 0) {
+			smclog(LOG_WARNING, 0, "%02d: Invalid source IPv6 address: %s", lineno, source ?: "NONE");
 			return 1;
 		}
 
-		if (inet_pton(AF_INET6, group, &mroute.group) <= 0 || !IN6_IS_ADDR_MULTICAST(&mroute.group)) {
-			smclog(LOG_WARNING, 0, "Line %02d: Invalid IPv6 multicast group: %s", lineno, group);
+		if (inet_pton(AF_INET6, group, &mroute.group.sin6_addr) <= 0 || !IN6_IS_ADDR_MULTICAST(&mroute.group.sin6_addr)) {
+			smclog(LOG_WARNING, 0, "%02d: Invalid IPv6 multicast group: %s", lineno, group);
 			return 1;
 		}
 
@@ -137,18 +141,18 @@
 
 			if (mif < 0) {
 				total--;
-				smclog(LOG_WARNING, 0, "Line %02d: Invalid outbound IPv6 interface: %s", lineno, outbound[i]);
+				smclog(LOG_WARNING, 0, "%02d: Invalid outbound IPv6 interface: %s", lineno, outbound[i]);
 				continue; /* Try next, if any. */
 			}
 
 			if (mif == mroute.inbound)
-				smclog(LOG_WARNING, 0, "Line %02d: Same outbound IPv6 interface (%s) as inbound (%s)?", lineno, outbound[i], ifname);
+				smclog(LOG_WARNING, 0, "%02d: Same outbound IPv6 interface (%s) as inbound (%s)?", lineno, outbound[i], ifname);
 
 			mroute.ttl[mif] = 1;	/* Use a TTL threshold to indicate the list of outbound interfaces. */
 		}
 
 		if (!total) {
-			smclog(LOG_WARNING, 0, "Line %02d: No valid outbound interfaces, skipping mroute rule.", lineno);
+			smclog(LOG_WARNING, 0, "%02d: No valid outbound interfaces, skipping multicast route.", lineno);
 			result = 1;
 		} else {
 			result = mroute6_add(&mroute);
@@ -160,19 +164,19 @@
 		memset(&mroute, 0, sizeof(mroute));
 		mroute.inbound = iface_get_vif_by_name(ifname);
 		if (mroute.inbound < 0) {
-			smclog(LOG_WARNING, 0, "Line %02d: Invalid inbound IPv4 interface: %s", lineno, ifname);
+			smclog(LOG_WARNING, 0, "%02d: Invalid inbound IPv4 interface: %s", lineno, ifname);
 			return 1;
 		}
 
 		if (!source) {
 			mroute.sender.s_addr = INADDR_ANY;
 		} else if (inet_pton(AF_INET, source, &mroute.sender) <= 0) {
-			smclog(LOG_WARNING, 0, "Line %02d: Invalid source IPv4 address: %s", lineno, source);
+			smclog(LOG_WARNING, 0, "%02d: Invalid source IPv4 address: %s", lineno, source);
 			return 1;
 		}
 
 		if ((inet_pton(AF_INET, group, &mroute.group) <= 0) || !IN_MULTICAST(ntohl(mroute.group.s_addr))) {
-			smclog(LOG_WARNING, 0, "Line %02d: Invalid IPv4 multicast group: %s", lineno, group);
+			smclog(LOG_WARNING, 0, "%02d: Invalid IPv4 multicast group: %s", lineno, group);
 			return 1;
 		}
 
@@ -182,18 +186,18 @@
 
 			if (vif < 0) {
 				total--;
-				smclog(LOG_WARNING, 0, "Line %02d: Invalid outbound IPv4 interface: %s", lineno, outbound[i]);
+				smclog(LOG_WARNING, 0, "%02d: Invalid outbound IPv4 interface: %s", lineno, outbound[i]);
 				continue; /* Try next, if any. */
 			}
 
 			if (vif == mroute.inbound)
-				smclog(LOG_WARNING, 0, "Line %02d: Same outbound IPv4 interface (%s) as inbound (%s)?", lineno, outbound[i], ifname);
+				smclog(LOG_WARNING, 0, "%02d: Same outbound IPv4 interface (%s) as inbound (%s)?", lineno, outbound[i], ifname);
 
 			mroute.ttl[vif] = 1;	/* Use a TTL threshold to indicate the list of outbound interfaces. */
 		}
 
 		if (!total) {
-			smclog(LOG_WARNING, 0, "Line %02d: No valid outbound IPv4 interfaces, skipping mroute rule.", lineno);
+			smclog(LOG_WARNING, 0, "%02d: No valid outbound IPv4 interfaces, skipping multicast route.", lineno);
 			result = 1;
 		} else {
 			result = mroute4_add(&mroute);
@@ -203,7 +207,15 @@
 	return result;
 }
 
-/* Format:
+/**
+ * parse_conf_file - Parse smcroute.conf
+ * @file: File name to parse
+ *
+ * This function parses the given @file according to the below format rules.
+ * Joins multicast groups and creates multicast routes accordingly in the
+ * kernel.
+ *
+ * Format:
  *    mgroup from IFNAME group MCGROUP
  *    mroute from IFNAME source ADDRESS group MCGROUP to IFNAME [IFNAME ...]
  */
@@ -289,7 +301,7 @@
 		else if (op == 2)
 			add_mroute(lineno, ifname, group, source, dest, num);
 #endif	/* UNITTEST */
-		
+
 		lineno++;
 	}
 
diff -urN smcroute-1.99.2/src/smcroute.c smcroute/src/smcroute.c
--- smcroute-1.99.2/src/smcroute.c	2013-07-16 06:59:37.000000000 +0200
+++ smcroute/src/smcroute.c	2014-06-30 12:22:34.849800512 +0200
@@ -1,28 +1,25 @@
-/*
-**  smcroute - static multicast routing control 
-**  Copyright (C) 2001-2005 Carsten Schill <carsten@cschill.de>
-**  Copyright (C) 2006-2008 Julien BLACHE <jb@jblache.org>
-**  Copyright (C) 2006-2009 Julien BLACHE <jb@jblache.org>
-**  Copyright (C) 2009      Todd Hayton <todd.hayton@gmail.com>
-**  Copyright (C) 2009-2011 Micha Lenk <micha@debian.org>
-**  Copyright (C) 2011      Joachim Nilsson <troglobit@gmail.com>
-**
-**  This program is free software; you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation; either version 2 of the License, or
-**  (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
-**
-**  $Id: smcroute.c 86 2011-08-08 17:09:45Z micha $	
-*/
+/* Daemon and client main routines
+ *
+ * Copyright (C) 2001-2005  Carsten Schill <carsten@cschill.de>
+ * Copyright (C) 2006-2009  Julien BLACHE <jb@jblache.org>
+ * Copyright (C) 2009       Todd Hayton <todd.hayton@gmail.com>
+ * Copyright (C) 2009-2011  Micha Lenk <micha@debian.org>
+ * Copyright (C) 2011-2013  Joachim Nilsson <troglobit@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ */
 
 #include <stdio.h>
 #include <sys/types.h>
@@ -42,34 +39,32 @@
 #include "config.h"
 #include "build.h"
 
+int do_debug_logging = 0;
+
+static int         running   = 1;
+static const char *conf_file = SMCROUTE_SYSTEM_CONF;
+
 extern char *__progname;
 static const char version_info[] =
-	"smcroute, Version " PACKAGE_VERSION ", Build" BUILD "\n"
-	"Copyright (c) 2001-2005  Carsten Schill <carsten@cschill.de>\n"
-	"Copyright (c) 2006-2009  Julien Blache <jb@jblache.org>,\n"
-	"                   2009  Todd Hayton <todd.hayton@gmail.com>, and\n"
-	"              2009-2011  Micha Lenk <micha@debian.org>\n"
-	"                   2011  Joachim Nilsson <troglobit@gmail.com>\n"
-	"Distributed under the GNU GENERAL PUBLIC LICENSE, Version 2\n"
-	"\n";
+	"SMCRoute version " PACKAGE_VERSION " build" BUILD "\n";
 
 static const char usage_info[] =
 	"Usage: smcroute [OPTIONS]... [ARGS]...\n"
 	"\n"
-	"  -d       Start smcroute daemon.\n"
-	"  -n       Run daemon in foreground, i.e., do not fork.\n"
-	"  -f FILE  Use FILE as daemon configuration. Default: " SMCROUTE_SYSTEM_CONF "\n"
-	"  -k       Stop (kill) a running daemon.\n"
+	"  -d       Start daemon\n"
+	"  -n       Run daemon in foreground\n"
+	"  -f FILE  File to use instead of default " SMCROUTE_SYSTEM_CONF "\n"
+	"  -k       Kill a running daemon\n"
 	"\n"
-	"  -h       Display this help text.\n"
-	"  -D       Debug logging.\n"
-	"  -v       Display version information and enable verbose logging.\n"
+	"  -h       This help text\n"
+	"  -D       Debug logging\n"
+	"  -v       Show version and enable verbose logging\n"
 	"\n"
-	"  -a ARGS  Add a multicast route, full syntax below.\n"
-	"  -r ARGS  Remove a multicast route, full syntax below.\n"
+	"  -a ARGS  Add a multicast route\n"
+	"  -r ARGS  Remove a multicast route\n"
 	"\n"
-	"  -j ARGS  Join a multicast group on an interface, useful for testing.\n"
-	"  -l ARGS  Leave a multicast group on an interface, useful for testing.\n"
+	"  -j ARGS  Join a multicast group\n"
+	"  -l ARGS  Leave a multicast group\n"
 	"\n"
 	"     <------------- INBOUND -------------->  <----- OUTBOUND ------>\n"
 	"  -a <IFNAME> <SOURCE-IP> <MULTICAST-GROUP>  <IFNAME> [<IFNAME> ...]\n"
@@ -78,50 +73,14 @@
 	"  -j <IFNAME> <MULTICAST-GROUP>\n"
 	"  -l <IFNAME> <MULTICAST-GROUP>\n";
 
-static int sighandled = 0;
-#define	GOT_SIGINT	0x01
-#define	GOT_SIGHUP	0x02
-
-int do_debug_logging = 0;
-
 /*
- * Signal handler.  Take note of the fact that the signal arrived
- * so that the main loop can take care of it.
+ * Counts the number of arguments belonging to an option. Option is any argument
+ * begining with a '-'.
+ *
+ * returns: - the number of arguments (without the option itself),
+ *          - 0, if we start already from the end of the argument vector
+ *          - -1, if we start not from an option
  */
-static void handler(int sig)
-{
-    switch (sig) {
-    case SIGINT:
-    case SIGTERM:
-	sighandled |= GOT_SIGINT;
-	break;
-
-    case SIGHUP:
-	sighandled |= GOT_SIGHUP;
-	break;
-    }
-}
-
-static void signal_init(void)
-{
-	struct sigaction sa;
-
-	sa.sa_handler = handler;
-	sa.sa_flags = 0;	/* Interrupt system calls */
-	sigemptyset(&sa.sa_mask);
-	sigaction(SIGHUP, &sa, NULL);
-	sigaction(SIGTERM, &sa, NULL);
-	sigaction(SIGINT, &sa, NULL);
-}
-
-/*
-** Counts the number of arguments belonging to an option. Option is any argument
-** begining with a '-'. 
-** 
-** returns: - the number of arguments (without the option itself), 
-**          - 0, if we start already from the end of the argument vector
-**          - -1, if we start not from an option
-*/
 static int num_option_arguments(const char *argv[])
 {
 	const char **ptr;
@@ -145,24 +104,24 @@
 {
 	if (access(conf_file, R_OK)) {
 		smclog(LOG_WARNING, errno, "Failed loading %s", conf_file);
-	} else {
-		if (parse_conf_file(conf_file))
-			smclog(LOG_WARNING, errno, "Failed reading %s", conf_file);
+		return;
 	}
+
+	if (parse_conf_file(conf_file))
+		smclog(LOG_WARNING, errno, "Failed reading %s", conf_file);
 }
 
 /* Cleans up, i.e. releases allocated resources. Called via atexit() */
 static void clean(void)
 {
-	smclog(LOG_DEBUG, 0, "clean handler called");
 	mroute4_disable();
 	mroute6_disable();
 	ipc_exit();
+	smclog(LOG_NOTICE, 0, "Exiting.");
 }
 
 static void restart(void)
 {
-	smclog(LOG_DEBUG, 0, "Restart handler called");
 	mroute4_disable();
 	mroute6_disable();
 	mcgroup4_disable();
@@ -179,56 +138,226 @@
 {
 	int pid;
 
-	smclog(LOG_NOTICE, 0, "Forking daemon process.");
-
 	pid = fork();
+	if (pid < 0)
+		smclog(LOG_ERR, errno, "Cannot start in background");
 	if (!pid) {
 		/* Detach deamon from terminal */
 		if (close(0) < 0 || close(1) < 0 || close(2) < 0
 		    || open("/dev/null", 0) != 0 || dup2(0, 1) < 0
 		    || dup2(0, 2) < 0 || setpgrp() < 0)
-			smclog(LOG_ERR, errno, "Failed to detach deamon");
+			smclog(LOG_ERR, errno, "Failed detaching deamon");
 	}
 
 	return pid;
 }
 
-static void server_loop(int sd, const char *conf_file)
+/* Check for kernel IGMPMSG_NOCACHE for (*,G) hits. I.e., source-less routes. */
+static int read_mroute4_socket(void)
 {
 	int result;
-	uint8 buf[MX_CMDPKT_SZ];
-	fd_set fds;
-#ifdef HAVE_IPV6_MULTICAST_ROUTING
-	int max_fd_num = MAX(sd, MAX(mroute4_socket, mroute6_socket));
-#else
-	int max_fd_num = MAX(sd, mroute4_socket);
-#endif
+	char tmp[128];
+	struct ip *ip;
+	struct igmpmsg *igmpctl;
+
+	memset(tmp, 0, sizeof(tmp));
+	result = read(mroute4_socket, tmp, sizeof(tmp));
+
+	/* packets sent up from kernel to daemon have ip->ip_p = 0 */
+	ip = (struct ip *)tmp;
+	igmpctl = (struct igmpmsg *)tmp;
+
+	/* Check for IGMPMSG_NOCACHE to do (*,G) based routing. */
+	if (ip->ip_p == 0 && igmpctl->im_msgtype == IGMPMSG_NOCACHE) {
+		struct iface *iface;
+		mroute4_t mroute;
+
+		mroute.group.s_addr  = igmpctl->im_dst.s_addr;
+		mroute.sender.s_addr = igmpctl->im_src.s_addr;
+		mroute.inbound       = igmpctl->im_vif;
+
+		iface = iface_find_by_vif(mroute.inbound);
+		if (!iface) {
+			/* TODO: Add support for dynamically re-enumerating VIFs at runtime! */
+			smclog(LOG_WARNING, 0, "No VIF for possibly dynamic inbound iface %s, cannot add mroute dynamically.", mroute.inbound);
+			return 1;
+		}
+
+		/* Find any matching route for this group on that iif. */
+		mroute4_dyn_add(&mroute);
+	}
+
+	return result;
+}
+
+/* Receive and drop ICMPv6 stuff. This is either MLD packets or upcall messages sent up from the kernel. */
+static int read_mroute6_socket(void)
+{
+	char tmp[128];
+
+	if (mroute6_socket < 0)
+		return;
+
+	return read(mroute6_socket, tmp, sizeof(tmp));
+}
+
+/* Receive command from the smcroute client */
+static int read_ipc_command(void)
+{
 	const char *str;
 	struct cmd *packet;
 	struct mroute mroute;
+	uint8 buf[MX_CMDPKT_SZ];
 
-	smclog(LOG_NOTICE, 0, "Attempting to load %s", conf_file);
-	read_conf_file (conf_file);
+	memset(buf, 0, sizeof(buf));
+	packet = ipc_server_read(buf, sizeof(buf));
+	if (!packet) {
+		/* Skip logging client disconnects */
+		if (errno != ECONNRESET)
+			smclog(LOG_WARNING, errno, "Failed receving IPC message from client");
+		return 1;
+	}
 
-	/* Ready for input, tell clients that by creating the pidfile */
-	if (pidfile(NULL))
-		smclog(LOG_WARNING, errno, "Failed creating pidfile");
+	switch (packet->cmd) {
+	case 'a':
+	case 'r':
+		if ((str = cmd_convert_to_mroute(&mroute, packet))) {
+			smclog(LOG_WARNING, 0, str);
+			ipc_send(log_last_message, strlen(log_last_message) + 1);
+			break;
+		}
 
-	/* Watch the MRouter and the IPC socket to the smcroute client */
-	while (1) {
-		if (sighandled) {
-			if (sighandled & GOT_SIGINT) {
-				sighandled &= ~GOT_SIGINT;
+		if (mroute.version == 4) {
+			if ((packet->cmd == 'a' && mroute4_add(&mroute.u.mroute4))
+			    || (packet->cmd == 'r' && mroute4_del(&mroute.u.mroute4))) {
+				ipc_send(log_last_message, strlen(log_last_message) + 1);
+				break;
+			}
+		} else {
+#ifndef HAVE_IPV6_MULTICAST_ROUTING
+			smclog(LOG_WARNING, 0, "IPv6 multicast routing support disabled.");
+#else
+			if ((packet->cmd == 'a' && mroute6_add(&mroute.u.mroute6))
+			    || (packet->cmd == 'r' && mroute6_del(&mroute.u.mroute6))) {
+				ipc_send(log_last_message, strlen(log_last_message) + 1);
+				break;
+			}
+#endif /* HAVE_IPV6_MULTICAST_ROUTING */
+		}
+
+		ipc_send("", 1);
+		break;
+
+	case 'j':	/* j <InputIntf> <McGroupAdr> */
+	case 'l':	/* l <InputIntf> <McGroupAdr> */
+	{
+		int result = -1;
+		const char *ifname = (const char *)(packet + 1);
+		const char *groupstr = ifname + strlen(ifname) + 1;
+
+		if (strchr(groupstr, ':') == NULL) {
+			struct in_addr group;
+
+			/* check multicast address */
+			if (!*groupstr
+			    || !inet_aton(groupstr, &group)
+			    || !IN_MULTICAST(ntohl(group.s_addr))) {
+				smclog(LOG_WARNING, 0, "Invalid multicast group: %s", groupstr);
+				ipc_send(log_last_message, strlen(log_last_message) + 1);
 				break;
 			}
-			if (sighandled & GOT_SIGHUP) {
-				sighandled &= ~GOT_SIGHUP;
-				restart();
-				smclog(LOG_NOTICE, 0, "Got SIGHUP, reloading %s ...", conf_file);
-				read_conf_file (conf_file);
+
+			/* join or leave */
+			if (packet->cmd == 'j')
+				result = mcgroup4_join(ifname, group);
+			else
+				result = mcgroup4_leave(ifname, group);
+		} else {	/* IPv6 */
+#ifndef HAVE_IPV6_MULTICAST_HOST
+			smclog(LOG_WARNING, 0, "IPv6 multicast support disabled.");
+#else
+			struct in6_addr group;
+
+			/* check multicast address */
+			if (!*groupstr
+			    || (inet_pton(AF_INET6, groupstr, &group) <= 0)
+			    || !IN6_IS_ADDR_MULTICAST(&group)) {
+				smclog(LOG_WARNING, 0, "Invalid multicast group: %s", groupstr);
+				ipc_send(log_last_message, strlen(log_last_message) + 1);
+				break;
 			}
+
+			/* join or leave */
+			if (packet->cmd == 'j')
+				result = mcgroup6_join(ifname, group);
+			else
+				result = mcgroup6_leave(ifname, group);
+#endif /* HAVE_IPV6_MULTICAST_HOST */
+		}
+
+		/* failed */
+		if (result) {
+			ipc_send(log_last_message, strlen(log_last_message) + 1);
+			break;
 		}
 
+		ipc_send("", 1);
+		break;
+	}
+
+	case 'k':
+		ipc_send("", 1);
+		exit(0);
+	}
+
+	return 0;
+}
+
+/*
+ * Signal handler.  Take note of the fact that the signal arrived
+ * so that the main loop can take care of it.
+ */
+static void handler(int sig)
+{
+	switch (sig) {
+	case SIGINT:
+	case SIGTERM:
+		running = 0;
+		break;
+
+	case SIGHUP:
+		smclog(LOG_NOTICE, 0, "Got SIGHUP, reloading %s ...", conf_file);
+		restart();
+		read_conf_file(conf_file);
+		break;
+	}
+}
+
+static void signal_init(void)
+{
+	struct sigaction sa;
+
+	sa.sa_handler = handler;
+	sa.sa_flags = 0;	/* Interrupt system calls */
+	sigemptyset(&sa.sa_mask);
+	sigaction(SIGHUP, &sa, NULL);
+	sigaction(SIGTERM, &sa, NULL);
+	sigaction(SIGINT, &sa, NULL);
+}
+
+static void server_loop(int sd)
+{
+	fd_set fds;
+#ifdef HAVE_IPV6_MULTICAST_ROUTING
+	int max_fd_num = MAX(sd, MAX(mroute4_socket, mroute6_socket));
+#else
+	int max_fd_num = MAX(sd, mroute4_socket);
+#endif
+
+	/* Watch the MRouter and the IPC socket to the smcroute client */
+	while (running) {
+		int result;
+
 		FD_ZERO(&fds);
 		FD_SET(sd, &fds);
 		FD_SET(mroute4_socket, &fds);
@@ -246,196 +375,61 @@
 			continue;
 		}
 
-		/* Check for kernel IGMPMSG_NOCACHE for (*,G) hits. I.e., source-less routes. */
-		if (FD_ISSET(mroute4_socket, &fds)) {
-			char tmp[128];
-			struct ip *ip;
-			struct igmpmsg *igmpctl;
-
-			memset (tmp, 0, sizeof(tmp));
-			result = read(mroute4_socket, tmp, sizeof(tmp));
-
-			/* packets sent up from kernel to daemon have ip->ip_p = 0 */
-			ip = (struct ip *)tmp;
-			igmpctl = (struct igmpmsg *)tmp;
-
-			/* Check for IGMPMSG_NOCACHE to do (*,G) based routing. */
-			if (ip->ip_p == 0 && igmpctl->im_msgtype == IGMPMSG_NOCACHE) {
-				char sbuf[16], gbuf[16];
-				struct iface *iface;
-				mroute4_t mroute;
-
-				mroute.group.s_addr  = igmpctl->im_dst.s_addr;
-				mroute.sender.s_addr = igmpctl->im_src.s_addr;
-				mroute.inbound       = igmpctl->im_vif;
-				iface = iface_find_by_vif (mroute.inbound);
-
-				/* Find any matching route for this group on that iif. */
-				smclog(LOG_DEBUG, 0, "Cache miss for group %s from %s on interface %s(%d) ifindex:%d",
-				       inet_ntop (AF_INET, &mroute.group, gbuf, sizeof(gbuf)),
-				       inet_ntop (AF_INET, &mroute.sender, sbuf, sizeof(sbuf)),
-				       iface ? iface->name : "unknown", mroute.inbound,
-				       iface ? iface->ifindex : -1);
-				mroute4_dyn_add(&mroute);
-			} else {
-				smclog(LOG_DEBUG, 0, "%d byte IGMP signaling dropped", result);
-			}
-		}
+		if (FD_ISSET(mroute4_socket, &fds))
+			read_mroute4_socket();
 
-		/* Receive and drop ICMPv6 stuff. This is either MLD packets
-		 * or upcall messages sent up from the kernel.
-		 */
 #ifdef HAVE_IPV6_MULTICAST_ROUTING
-		if (-1 != mroute6_socket && FD_ISSET(mroute6_socket, &fds)) {
-			char tmp[128];
-
-			result = read(mroute6_socket, tmp, sizeof(tmp));
-			smclog(LOG_DEBUG, 0, "%d byte MLD signaling dropped", result);
-		}
+		if (-1 != mroute6_socket && FD_ISSET(mroute6_socket, &fds))
+			read_mroute6_socket();
 #endif
 
 		/* loop back to select if there is no smcroute command */
-		if (!FD_ISSET(sd, &fds))
-			continue;
-
-		/* receive the command from the smcroute client */
-		packet = ipc_server_read(buf, sizeof(buf));
-		switch (packet->cmd) {
-		case 'a':
-		case 'r':
-			if ((str = cmd_convert_to_mroute(&mroute, packet))) {
-				smclog(LOG_WARNING, 0, str);
-				ipc_send(log_last_message, strlen(log_last_message) + 1);
-				break;
-			}
-
-			if (mroute.version == 4) {
-				if ((packet->cmd == 'a' && mroute4_add(&mroute.u.mroute4))
-				    || (packet->cmd == 'r' && mroute4_del(&mroute.u.mroute4))) {
-					ipc_send(log_last_message, strlen(log_last_message) + 1);
-					break;
-				}
-			} else {
-#ifndef HAVE_IPV6_MULTICAST_ROUTING
-				smclog(LOG_WARNING, 0, "Not built with IPv6 routing support.");
-#else
-				if ((packet->cmd == 'a' && mroute6_add(&mroute.u.mroute6))
-				    || (packet->cmd == 'r' && mroute6_del(&mroute.u.mroute6))) {
-					ipc_send(log_last_message, strlen(log_last_message) + 1);
-					break;
-				}
-#endif				/* HAVE_IPV6_MULTICAST_ROUTING */
-			}
-
-			ipc_send("", 1);
-			break;
-
-		case 'j':	/* j <InputIntf> <McGroupAdr> */
-		case 'l':	/* l <InputIntf> <McGroupAdr> */
-		{
-			int result = -1;
-			const char *ifname = (const char *)(packet + 1);
-			const char *groupstr = ifname + strlen(ifname) + 1;
-
-			if (strchr(groupstr, ':') == NULL) {
-				struct in_addr group;
-
-				/* check multicast address */
-				if (!*groupstr
-				    || !inet_aton(groupstr, &group)
-				    || !IN_MULTICAST(ntohl(group.s_addr))) {
-					smclog(LOG_WARNING, 0, "invalid multicast group address: '%s'", groupstr);
-					ipc_send(log_last_message, strlen(log_last_message) + 1);
-					break;
-				}
-
-				/* join or leave */
-				if (packet->cmd == 'j')
-					result = mcgroup4_join(ifname, group);
-				else
-					result = mcgroup4_leave(ifname, group);
-			} else {	/* IPv6 */
-#ifndef HAVE_IPV6_MULTICAST_HOST
-				smclog(LOG_WARNING, 0, "Not built with IPv6 support.");
-#else
-				struct in6_addr group;
-
-				/* check multicast address */
-				if (!*groupstr
-				    || (inet_pton(AF_INET6, groupstr, &group) <= 0)
-				    || !IN6_IS_ADDR_MULTICAST(&group)) {
-					smclog(LOG_WARNING, 0, "invalid multicast group address: '%s'", groupstr);
-					ipc_send(log_last_message, strlen(log_last_message) + 1);
-					break;
-				}
-
-				/* join or leave */
-				if (packet->cmd == 'j')
-					result = mcgroup6_join(ifname, group);
-				else
-					result = mcgroup6_leave(ifname, group);
-#endif				/* HAVE_IPV6_MULTICAST_HOST */
-			}
-
-			/* failed */
-			if (result) {
-				ipc_send(log_last_message, strlen(log_last_message) + 1);
-				break;
-			}
-
-			ipc_send("", 1);
-			break;
-		}
-
-		case 'k':
-			ipc_send("", 1);
-			exit(0);
-		}
+		if (FD_ISSET(sd, &fds))
+			read_ipc_command();
 	}
 }
 
 /* Init everything before forking, so we can fail and return an
  * error code in the parent and the initscript will fail */
-static void start_server(int background, const char *conf_file)
+static void start_server(int background)
 {
-	int sd, pid = 0;
-	unsigned short initialized_api_count;
+	int sd, api = 0;
+
+	if (background && daemonize())
+		return;
 
-	/* Build list of multicast-capable physical interfaces that 
+	smclog(LOG_NOTICE, 0, "%s", version_info);
+
+	/* Build list of multicast-capable physical interfaces that
 	 * are currently assigned an IP address. */
 	iface_init();
 
-	initialized_api_count = 0;
-	if (mroute4_enable() == 0)
-		initialized_api_count++;
+	if (!mroute4_enable())
+		api++;
 
-	if (mroute6_enable() == 0)
-		initialized_api_count++;
+	if (!mroute6_enable())
+		api++;
 
 	/* At least one API (IPv4 or IPv6) must have initialized successfully
 	 * otherwise we abort the server initialization. */
-	if (initialized_api_count == 0) {
+	if (!api) {
 		smclog(LOG_INIT, ENOPROTOOPT, "Kernel does not support multicast routing");
 		exit(1);
 	}
 
 	sd = ipc_server_init();
-	if (sd < 0) {
-		clean();
-		exit(2);
-	}
+	if (sd < 0)
+		smclog(LOG_WARNING, errno, "Failed setting up IPC socket, client communication disabled");
 
-	if (background)
-		pid = daemonize();
-	else
-		smclog(LOG_NOTICE, 0, "Starting daemon in foreground.");
+	atexit(clean);
+	signal_init();
+	read_conf_file(conf_file);
 
-	if (!pid) {
-		smclog(LOG_NOTICE, 0, "Entering smcroute daemon main loop.");
-		atexit(clean);
-		signal_init();
-		server_loop(sd, conf_file);
-	}
+	/* Everything setup, notify any clients by creating the pidfile */
+	if (pidfile(NULL))
+		smclog(LOG_WARNING, errno, "Failed creating pidfile");
+
+	server_loop(sd);
 }
 
 static int usage(void)
@@ -446,19 +440,22 @@
 	return 1;
 }
 
-/*
-** main program
-** - Parses command line options
-**   - daemon mode: enters daemon status and goes in receive-execute command loop 
-**   - client mode: creates commands from command line and sends them to the daemon
-*/
+/**
+ * main - Main program
+ *
+ * Parses command line options and enters either daemon or client mode.
+ *
+ * In daemon mode, acquires multicast routing sockets, opens IPC socket
+ * and goes in receive-execute command loop.
+ *
+ * In client mode, creates commands from command line and sends them to
+ * the daemon.
+ */
 int main(int argc, const char *argv[])
 {
-	int num_opts, result = 0;
+	int i, num_opts, result = 0;
 	int start_daemon = 0;
 	int background = 1;
-	uint8 buf[MX_CMDPKT_SZ];
-	const char *arg, *conf_file = SMCROUTE_SYSTEM_CONF;
 	unsigned int cmdnum = 0;
 	struct cmd *cmdv[16];
 
@@ -470,6 +467,8 @@
 
 	/* Parse command line options */
 	for (num_opts = 1; (num_opts = num_option_arguments(argv += num_opts));) {
+		const char *arg;
+
 		if (num_opts < 0)	/* error */
 			return usage();
 
@@ -477,32 +476,24 @@
 		arg = argv[0];
 		switch (arg[1]) {
 		case 'a':	/* add route */
-			if (num_opts < 5) {
-				fprintf(stderr, "Not enough arguments for 'add' command\n");
+			if (num_opts < 5)
 				return usage();
-			}
 			break;
 
 		case 'r':	/* remove route */
-			if (num_opts < 4) {
-				fprintf(stderr, "Wrong number of  arguments for 'remove' command\n");
+			if (num_opts < 4)
 				return usage();
-			}
 			break;
 
 		case 'j':	/* join */
 		case 'l':	/* leave */
-			if (num_opts != 3) {
-				fprintf(stderr, "Wrong number of arguments for %s command\n", arg[1] == 'j' ? "'join'" : "'leave'");
+			if (num_opts != 3)
 				return usage();
-			}
 			break;
 
 		case 'k':	/* kill daemon */
-			if (num_opts != 1) {
-				fprintf(stderr, "No arguments allowed for 'k' option\n");
+			if (num_opts != 1)
 				return usage();
-			}
 			break;
 
 		case 'h':	/* help */
@@ -522,10 +513,8 @@
 			continue;
 
 		case 'f':
-			if (num_opts != 2) {
-				fprintf(stderr, "Missing configuration file arguments for 'f' option\n");
+			if (num_opts != 2)
 				return usage();
-			}
 			conf_file = argv[1];
 			continue;
 
@@ -534,7 +523,6 @@
 			continue;
 
 		default:	/* unknown option */
-			fprintf(stderr, "Unknown option: %s\n", *argv);
 			return usage();
 		}
 
@@ -544,35 +532,40 @@
 			return usage();
 		}
 
-		cmdv[cmdnum++] = cmd_build(arg[1], argv + 1, num_opts - 1);
+		cmdv[cmdnum] = cmd_build(arg[1], argv + 1, num_opts - 1);
+		if (!cmdv[cmdnum]) {
+			perror("Failed parsing command");
+			for (i = 0; i < cmdnum; i++)
+				free(cmdv[i]);
+			return 1;
+		}
+		cmdnum++;
 	}
 
 	if (start_daemon) {	/* only daemon parent enters */
 		if (geteuid() != 0) {
-			smclog(LOG_ERR, 0, "Must have super-user permissions to start %s.", __progname);
-			exit(1);
+			smclog(LOG_ERR, 0, "Need root privileges to start %s", __progname);
+			return 1;
 		}
-		start_server(background, conf_file);
+
+		start_server(background);
 		if (!background)
-			exit (0); /* Exit if non-backgrounded daemon exits this way. */
+			return 0;
 	}
 
 	/* Client or daemon parent only, the daemon never reaches this point */
 
 	/* send commands */
 	if (cmdnum) {
-		unsigned int i;
-		int code, retry_count = 30;
+		int retry_count = 30;
 
 		openlog(argv[0], LOG_PID, LOG_USER);
 
-	retry:
 		/* connect to daemon */
-		code = ipc_client_init();
-		if (code) {
-			switch (code) {
+		while (ipc_client_init()) {
+			switch (errno) {
 			case EACCES:
-				smclog(LOG_ERR, EACCES, "Need super-user permissions to connect to daemon");
+				smclog(LOG_ERR, EACCES, "Need root privileges to connect to daemon");
 				break;
 
 			case ENOENT:
@@ -580,36 +573,43 @@
 				/* When starting daemon, give it 30 times a 1/10 second to get ready */
 				if (start_daemon && --retry_count) {
 					usleep(100000);
-					goto retry;
+					continue;
 				}
-				smclog(LOG_ERR, code, "Daemon not running");
+
+				smclog(LOG_WARNING, errno, "Daemon not running");
+				result = 1;
 				break;
 
 			default:
-				smclog(LOG_ERR, code, "Failed connecting to daemon");
+				smclog(LOG_WARNING, errno, "Failed connecting to daemon");
+				result = 1;
 				break;
 			}
 		}
 
-		for (i = 0; i < cmdnum; i++) {
-			int slen = 0, rlen = 0;
+		for (i = 0; !result && i < cmdnum; i++) {
+			int slen, rlen;
+			uint8 buf[MX_CMDPKT_SZ];
 			struct cmd *command = cmdv[i];
 
-			smclog(LOG_DEBUG, 0, "Sending command %c len:%zu count:%d", command->cmd, command->len, command->count);
+			/* Send command */
 			slen = ipc_send(command, command->len);
-			rlen = ipc_receive(buf, sizeof(buf));
-			if (slen < 0 || rlen < 0)
-				smclog(LOG_ERR, errno, "Read/Write to daemon failed");
 
-			smclog(LOG_DEBUG, 0, "rlen: %d", rlen);
+			/* Wait here for reply */
+			rlen = ipc_receive(buf, sizeof(buf));
+			if (slen < 0 || rlen < 0) {
+				smclog(LOG_WARNING, errno, "Communication with daemon failed");
+				result = 1;
+			}
 
 			if (rlen != 1 || *buf != '\0') {
 				fprintf(stderr, "Daemon error: %s\n", buf);
 				result = 1;
 			}
-
-			free(command);
 		}
+
+		for (i = 0; i < cmdnum; i++)
+			free(cmdv[i]);
 	}
 
 	return result;
diff -urN smcroute-1.99.2/src/syslog.c smcroute/src/syslog.c
--- smcroute-1.99.2/src/syslog.c	2013-07-16 06:59:37.000000000 +0200
+++ smcroute/src/syslog.c	2014-06-30 12:22:34.849800512 +0200
@@ -1,27 +1,25 @@
-/*
-**  smcroute - static multicast routing control 
-**  Copyright (C) 2001-2005 Carsten Schill <carsten@cschill.de>
-**  Copyright (C) 2006 Julien BLACHE <jb@jblache.org>
-**
-**  This program is free software; you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation; either version 2 of the License, or
-**  (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
-**
-**  $Id: syslog.c 87 2011-08-08 17:18:21Z micha $	
-**
-**  This module contains the interface functions for syslog
-**
-*/
+/* System logging API
+ *
+ * Copyright (C) 2001-2005  Carsten Schill <carsten@cschill.de>
+ * Copyright (C) 2006-2009  Julien BLACHE <jb@jblache.org>
+ * Copyright (C) 2009       Todd Hayton <todd.hayton@gmail.com>
+ * Copyright (C) 2009-2011  Micha Lenk <micha@debian.org>
+ * Copyright (C) 2011-2013  Joachim Nilsson <troglobit@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ */
 
 #include "mclab.h"
 
@@ -30,55 +28,32 @@
 int  log_last_error;
 char log_last_message[128];
 
-/*
-** Writes the message 'fmt' with the parameters '...' to syslog.
-** 'severity' is used for the syslog entry. For an 'code' value 
-** other then 0, the correponding error string is appended to the
-** message.
-**
-** For a 'severity' more important then 'LOG_WARNING' the message is 
-** also logged to 'stderr' and the program is finished with a call to 
-** 'exit()'.
-**
-** If the 'severity' is more important then 'log_stderr' the message
-** is logged to 'stderr'.
-**          
-*/
+/**
+ * smclog - Log message to syslog and stderr
+ * @severity: Standard syslog() severity levels or %LOG_INIT
+ * @code:     Error code, @errno, or zero if unused
+ * @fmt:      Standard printf() formatted message to log
+ *
+ * Logs a standard printf() formatted message to syslog and stderr when
+ * @severity is greater than the @log_stderr threshold.  When @code is
+ * set it is appended to the log, along with the error message.
+ *
+ * When @severity is %LOG_ERR or worse this function will call exit().
+ */
 void smclog(int severity, int code, const char *fmt, ...)
 {
-	int arg_len;
+	int len = 0;
 	va_list args;
-	const char severity_list[][5] = {
-		"EMER", "ALER", "CRIT", "ERRO",
-		"Warn", "Note", "Info", "Debu"
-	};
-	const char *severity_string;
-	const char *error_string = (code <= 0) ? NULL : (const char *)strerror(code);
-
-	/* LOG_INIT is a gross hack to work around smcroute's bad architecture
-	 * During daemon init, we do not want to trigger the exit() call at the end
-	 * of the function to be able to return an exit code from the parent before
-	 * we daemonize, without the parent triggering the atexit() handlers in the
-	 * normal case (which would remove the socket...)
-	 * That gross, ugly hack or a complete rewrite, for now the hack will do. */
-	if (severity < 0 || severity >= (int)ARRAY_ELEMENTS(severity_list)) {
-		if (severity == LOG_INIT)
-			severity_string = "INIT";
-		else
-			severity_string = "!unknown serverity!";
-	} else {
-		severity_string = severity_list[severity];
-	}
+	const char *err = (code <= 0) ? NULL : (const char *)strerror(code);
 
 	/* Skip logging for severities 'DEBUG' if do_debug_logging is false */
 	if (severity == LOG_DEBUG && !do_debug_logging)
 		return;
 
 	va_start(args, fmt);
-	arg_len  = snprintf(log_last_message, sizeof(log_last_message), "%s: ", severity_string);
-	arg_len += vsnprintf(log_last_message + arg_len, sizeof(log_last_message) - arg_len, fmt, args);
-	if (error_string)
-		snprintf(log_last_message + arg_len, sizeof(log_last_message) - arg_len, ". Error %d: %s", code, error_string);
+	len += vsnprintf(log_last_message + len, sizeof(log_last_message) - len, fmt, args);
+	if (err)
+		snprintf(log_last_message + len, sizeof(log_last_message) - len, ". Error %d: %s", code, err);
 	va_end(args);
 
 	/* update our global Last... variables */
@@ -86,7 +61,7 @@
 	log_last_error = code;
 
 	/* control logging to stderr */
-	if (severity < LOG_WARNING || severity < log_stderr || severity == LOG_INIT)
+	if (severity < log_stderr || severity == LOG_INIT)
 		fprintf(stderr, "%s\n", log_last_message);
 
 	/* always to syslog */
@@ -94,7 +69,7 @@
 
 	/* LOG_INIT doesn't trigger that */
 	if (severity <= LOG_ERR)
-		exit(-1);
+		exit(255);
 }
 
 /**
diff -urN smcroute-1.99.2/src/udpsock.c smcroute/src/udpsock.c
--- smcroute-1.99.2/src/udpsock.c	2013-07-16 06:59:37.000000000 +0200
+++ smcroute/src/udpsock.c	2014-06-30 12:22:34.849800512 +0200
@@ -1,36 +1,34 @@
-/*
-**  smcroute - static multicast routing control 
-**  Copyright (C) 2001-2005 Carsten Schill <carsten@cschill.de>
-**  Copyright (C) 2006 Julien BLACHE <jb@jblache.org>
-**
-**  This program is free software; you can redistribute it and/or modify
-**  it under the terms of the GNU General Public License as published by
-**  the Free Software Foundation; either version 2 of the License, or
-**  (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
-**
-**  $Id: udpsock.c 17 2006-06-24 12:34:30Z jblache $	
-**
-**  This module contains UDP socket function(s)
-**
-*/
+/* UDP socket API
+ *
+ * Copyright (C) 2001-2005  Carsten Schill <carsten@cschill.de>
+ * Copyright (C) 2006-2009  Julien BLACHE <jb@jblache.org>
+ * Copyright (C) 2009       Todd Hayton <todd.hayton@gmail.com>
+ * Copyright (C) 2009-2011  Micha Lenk <micha@debian.org>
+ * Copyright (C) 2011-2013  Joachim Nilsson <troglobit@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ */
 
 #include "mclab.h"
 
 /*
-** Creates and connects a simple UDP socket to the target 
-** 'inaddr':'Port'
-**
-** returns: - the opened socket
-*/
+ * Creates and connects a simple UDP socket to the target
+ * 'inaddr':'Port'
+ *
+ * returns: - the opened socket
+ */
 int udp_socket_open(uint32 inaddr, uint16 port)
 {
 	int sd;
